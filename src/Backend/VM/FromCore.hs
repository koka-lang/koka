-----------------------------------------------------------------------------
-- Copyright 2012-2021, Microsoft Research, Daan Leijen, Edsko de Vries.
--
-- This is free software; you can redistribute it and/or modify it under the
-- terms of the Apache License, Version 2.0. A copy of the License can be
-- found in the LICENSE file at the root of this distribution.
-----------------------------------------------------------------------------

module Backend.VM.FromCore
      ( vmFromCore )
 where

import Platform.Config(version)
import Lib.Trace
import Control.Applicative hiding (empty)
import Control.Monad
import qualified Control.Monad.Fail as F
import Data.List ( intersperse, partition )
import Data.Char
import Data.Bifunctor (bimap)

import qualified Data.Set as S

import Type.Type
import qualified Type.Pretty as Pretty

import Lib.PPrint
import Common.Name
import Common.NamePrim
import Common.Failure
import Common.Unique
import Common.Syntax

import Core.Core
import Core.Pretty
import Core.CoreVar

type CommentDoc   = Doc
type ConditionDoc = Doc -> Doc -> Doc -- cd thn els


debug :: Bool
debug  = True

externalNames :: [(TName, Doc)]
externalNames
  = [ (conName exprTrue,  text "true")
    , (conName exprFalse, text "false")
    , (TName nameOptionalNone typeOptional, text "undefined")  -- ugly but has real performance benefit
    ]

--------------------------------------------------------------------------
-- Generate JavaScript code from System-F core language
--------------------------------------------------------------------------

vmFromCore :: BuildType -> Maybe (Name,Bool) -> [Import] -> Core -> Doc
vmFromCore buildType mbMain imports core
  = runAsm (Env moduleName penv externalNames False) (genModule buildType mbMain imports core)
  where
    moduleName = coreProgName core
    penv       = Pretty.defaultEnv{ Pretty.context = moduleName, Pretty.fullNames = False }

genModule :: BuildType -> Maybe (Name,Bool) -> [Import] -> Core -> Asm Doc
genModule buildType mbMain imports core
  =  do decls0 <- genGroups True (coreProgDefs core)
        decls1 <- genTypeDefs (coreProgTypeDefs core)
        let -- `imports = coreProgImports core` is not enough due to inlined definitions
            (mainEntry) = case mbMain of
                          Nothing -> appPrim "is a library" [] (tpe "Unit")
                          Just (name,isAsync)
                            -> app (var (str $ show name) (tFn "Effectful" [] (tpe "Unit"))) []
        return $
                    obj
                    [ "metadata" .= 
                      obj [ "generated by" .= str "Koka"
                          , "koka version" .= str version
                          , "program name" .= str (show (coreProgName core))
                          ]
                    , "definitions" .=
                      list (decls0 
                           ++ decls1
                           )
                    , "main" .= mainEntry
                    ]

---------------------------------------------------------------------------------
-- Translate types
---------------------------------------------------------------------------------
transformType :: Type -> Doc
transformType (TVar _) = tpe "Ptr" -- erased
transformType (TForall _ _ t) = transformType t -- TODO do we need to thunk
transformType (TFun ps e t) = obj [ "op" .= str "Function"
                                  , "params" .= list [ transformType pt | (_,pt) <- ps]
                                  , "return" .= transformType t
                                  , "purity" .= str "Effectful" -- TODO infer from e
                                  ]
transformType (TCon c) | nameModule (typeConName c) == "std/core/types" = case (nameStem (typeConName c)) of 
  "unit" -> tpe "Unit" 
  "string" -> tpe "String"
  "bool" -> tpe "Int"
  "int" -> tpe "Int"
  t -> obj [ "op" .= str "Ptr", "extern_ptr_name" .= (str $ show t) ]
transformType (TCon c) = obj [ "op" .= str "Ptr", "extern_ptr_name" .= (str $ show $ typeConName c) ]
transformType (TApp t as) = transformType t
transformType (TSyn _ _ t) = transformType t

---------------------------------------------------------------------------------
-- Generate mcore statements for value definitions
---------------------------------------------------------------------------------

genGroups :: Bool -> [DefGroup] -> Asm [Doc]
genGroups topLevel groups
  = localUnique $ concat <$> mapM (genGroup topLevel) groups

genGroup :: Bool -> DefGroup -> Asm [Doc]
genGroup topLevel group
  = case group of
      DefRec defs   -> mapM (genDef topLevel) defs
      DefNonRec def -> (:[]) <$> genDef topLevel def

genDef :: Bool -> Def -> Asm Doc
genDef topLevel (Def name tp expr vis sort inl rng comm)
  = do let n = var (str $ show name) (transformType tp)
       v <- genExpr expr
       return $ def n v 

---------------------------------------------------------------------------------
-- Generate value constructors for each defined type
---------------------------------------------------------------------------------

genTypeDefs :: TypeDefGroups -> Asm [Doc]
genTypeDefs groups
  = concat <$> mapM (genTypeDefGroup) groups

genTypeDefGroup :: TypeDefGroup -> Asm [Doc]
genTypeDefGroup (TypeDefGroup tds)
  = concat <$> mapM (genTypeDef) tds

genTypeDef ::TypeDef -> Asm [Doc]
genTypeDef  (Synonym {})
  = return []
genTypeDef (Data info isExtend)
  = do modName <- getModule
       let (dataRepr, conReprs) = getDataRepr info
       mapM ( \(c,repr)  ->
          do let args = map (\(n,t) -> var (ppName n) (transformType t)) (conInfoParams c)
             let name = str $ show (conInfoName c)
             let tp = transformType $ conInfoType c
             penv <- getPrettyEnv
             let singletonValue val = def (var name (transformType (conInfoType c))) val
             if (conInfoName c == nameTrue)
             then return $ obj [ "op" .= str "Literal", "type" .= str "Int", "value" .= text "1" ]
             else if (conInfoName c == nameFalse)
             then return $ obj [ "op" .= str "Literal", "type" .= str "Int", "value" .= text "0" ]
             else return $ case repr of
                        -- special
                        ConEnum{}
                          -> debugWrap ("enum ") $ obj ["op" .= str "Literal", "type" .= str "Int", "value" .= int (conTag repr)]
--                         ConSingleton{} | conInfoName c == nameOptionalNone
--                           -> null
--                         ConSingleton _ DataStructAsMaybe _ _
--                           -> null
--                         ConSingleton _ DataAsMaybe _ _
--                           -> null
--                         ConSingleton _ DataAsList _ _
--                           -> null
                        -- normal
                        _            -> genConstr penv c repr name tp args
          ) $ zip (dataInfoConstrs $ info) conReprs
  where
    null = var (text "-1") (tpe "Ptr")
    genConstr penv c repr name tp args
      = def (var name tp) (debugWrap "genConstr" $
             obj [ "op" .= str "Abs", "params" .= list args
                 , "body" .= obj [ "op" .= str "Construct"
                                 , "type_tag" .= (getConTypeTag c)
                                 , "tag" .= name
                                 , "args" .= list args
                                 ]
                 ])

getConTypeTag info = case conInfoType info of
  TFun _ _ r -> str $ show $ r
getConTag modName coninfo repr
  = case repr of
      ConOpen{} -> -- ppLit (LitString (show (openConTag (conInfoName coninfo))))
                   let name = toOpenTagName (conInfoName coninfo)
                   in ppName (if (qualifier name == modName) then unqualify name else name)
      _ -> int (conTag repr)

openConTag name
  = name

---------------------------------------------------------------------------------
-- Statements
---------------------------------------------------------------------------------

-- | Applies a return context
getResult :: Result -> Doc -> Doc
getResult result doc
  = if isEmptyDoc doc
      then text ""
      else getResultX result (doc,doc)

getResultX result (puredoc,retdoc)
  = case result of
     ResultReturn _ _  -> retdoc
     ResultAssign n ml -> notImplemented $ ( if isWildcard n
                              then (if (isEmptyDoc puredoc) then puredoc else puredoc <.> semi)
                              else text "var" <+> ppName (unqualify n) <+> text "=" <+> retdoc <.> semi
                          ) <-> case ml of
                                  Nothing -> empty
                                  Just l  -> text "break" <+> ppName l <.> semi

tryTailCall :: Result -> Expr -> Asm (Maybe Doc)
tryTailCall result expr
  = case expr of
     -- Tailcall case 1
     App (Var n info) args  | ( case result of
                                  ResultReturn (Just m) _ -> m == getName n && infoArity info == (length args)
                                  _                       -> False
                              )
       -> do let (ResultReturn _ params) = result
             stmts <- genOverride params args
             return $ Just $ notImplemented $ block $ stmts <-> tailcall

     -- Tailcall case 2
     App (TypeApp (Var n info) _) args | ( case result of
                                            ResultReturn (Just m) _ -> m == getName n && infoArity info == (length args)
                                            _                       -> False
                                          )
       -> do let (ResultReturn _ params) = result
             stmts <- genOverride params args
             return $ Just $ notImplemented $ block $ stmts <-> tailcall

     _ -> return Nothing
  where
    -- overriding function arguments carefully
    genOverride :: [TName] -> [Expr] -> Asm Doc
    genOverride params args
      = fmap (debugWrap "genOverride") $
        do (stmts, varNames) <- do args' <- mapM tailCallArg args
                                   bs    <- mapM genVarBinding args'
                                   return (unzip bs)
           docs1             <- mapM genTName params
           docs2             <- mapM genTName varNames
           let assigns    = map (\(p,a)-> if p == a
                                            then debugComment ("genOverride: skipped overriding `" ++ (show p) ++ "` with itself")
                                            else debugComment ("genOverride: preparing tailcall") <.> p <+> text "=" <+> a <.> semi
                                ) (zip docs1 docs2)
           return $ notImplemented $
             linecomment (text "tail call") <-> list (concat stmts) <-> vcat assigns

    -- if local variables are captured inside a tailcalling function argument,
    -- we need to capture it by value (instead of reference since we will overwrite the local variables on a tailcall)
    -- we do this by wrapping the argument inside another function application.
    tailCallArg :: Expr -> Asm Expr
    tailCallArg expr
      = let captured = filter (not . isQualified . getName) $ tnamesList $ capturedVar expr
        in if (null captured)
            then return expr
            else -- trace ("Backend.JavaScript.FromCore.tailCall: capture: " ++ show captured ++ ":\n" ++ show expr) $
                 do ns <- mapM (newVarName . show) captured
                    let cnames = [TName cn tp | (cn,TName _ tp) <- zip ns captured]
                        sub    = [(n,Var cn InfoNone) | (n,cn) <- zip captured cnames]
                    return $ App (Lam cnames typeTotal (sub |~> expr)) [Var arg InfoNone | arg <- captured]

    capturedVar :: Expr -> TNames
    capturedVar expr
      = case expr of
          Lam _ _  _  -> fv expr  -- we only care about captures inside a lambda
          Let bgs body -> S.unions (capturedVar body : map capturedDefGroup bgs)
          Case es bs   -> S.unions (map capturedVar es ++ map capturedBranch bs)
          App f args   -> S.unions (capturedVar f : map capturedVar args)
          TypeLam _ e  -> capturedVar e
          TypeApp e _  -> capturedVar e
          _            -> S.empty

    capturedDefGroup bg
      = case bg of
          DefRec defs  -> S.difference (S.unions (map capturedDef defs)) (bv defs)
          DefNonRec def-> capturedDef def

    capturedDef def
      = capturedVar (defExpr def)

    capturedBranch (Branch pat grds)
      = S.difference (S.unions (map capturedGuard grds)) (bv pat)

    capturedGuard (Guard test expr)
      = S.union (capturedVar test) (capturedVar expr)

-- | Generates a statement from an expression by applying a return context (deeply) inside
genStat :: Result -> Expr -> Asm Doc
genStat result expr
  = fmap (debugWrap "genStat") $
           do mdoc <- tryTailCall result expr
              case mdoc of
                Just doc
                  -> return doc
                Nothing
                  -> genExprStat result expr


genExprStat result expr
  = case expr of
      -- If expression is inlineable, inline it
      _  | isInlineableExpr expr
        -> do exprDoc <- genInline expr
              return (getResult result exprDoc)

      Case exprs branches
         -> do (defss, scrutinees) <-  unzip <$> mapM (\e-> if isInlineableExpr e && isTypeBool (typeOf e)
                                                               then do d       <- genInline e
                                                                       return ([], d)
                                                               else do (sd,vn) <- genVarBinding e
                                                                       vd <- asVar vn
                                                                       return (sd, vd)
                                                       ) exprs
               doc                <- genMatch scrutinees branches
               return $ obj [ "op" .= str "LetRec"
                            , "definitions" .= list (concat defss)
                            , "body" .= doc
                            ]

      Let groups body
        -> do defs <- genGroups False groups
              body <- genStat result body
              return $ obj [ "op" .= str "LetRec"
                           , "definitions" .= list defs
                           , "body" .= body
                           ]

      -- Handling all other cases
      _ -> do (exprDoc) <- genExpr expr
              return (getResult result exprDoc)

-- | Generates a statement for a match expression regarding a given return context
genMatch :: [Doc] -> [Branch] -> Asm Doc
genMatch scrutinees branches
  = fmap (debugWrap "genMatch") $ do
    case branches of
        []  -> fail ("Backend.VM.FromCore.genMatch: no branch in match statement: " ++ show(scrutinees))
        [b] -> do (conds, d) <- genBranch scrutinees b
                  return $ debugWrap "genMatch: one case" $ (conjunction conds) d (appPrim "non-exhaustive match" [] (tpe "Bottom"))

        bs
           | all (\b-> length (branchGuards   b) == 1) bs
          && all (\b->isExprTrue $ guardTest $ head $ branchGuards b) bs
          -> do xs <- mapM (withStatement . genBranch scrutinees) bs
                let bs = foldr (.) id $ (map (\(conds,d) -> (conjunction conds d)) xs)
                return $ debugWrap "genMatch: guard-free case"
                       $ bs $ (appPrim "non-exhaustive match" [] (tpe "Bottom"))

        _ -> do bs <- mapM (withStatement . genBranch scrutinees) branches
                let ds = map (\(cds,stmts)-> if null cds
                                                  then stmts
                                                  else notImplemented $ text "if" <+> parens (conjunction cds (text "?thn") (text "?els"))
                                                                <+> block stmts
                             ) bs
                return $ notImplemented $ debugWrap "genMatch: regular case (with guards)"
                        (vcat ds)
  where
    -- | Generates a statement for a branch with given return context
    genBranch :: [Doc] -> Branch -> Asm ([ConditionDoc], Doc)
    -- Regular catch-all branch generation
    genBranch tnDocs branch@(Branch patterns guards)
      = do modName <- getModule
           (conditions, substs) <- bimap concat concat . unzip <$> mapM (genTest modName) (zip tnDocs patterns)
           let se         = withNameSubstitutions substs

           gs <- mapM (se . genGuard) guards
           return (conditions, debugWrap ("genBranch: " ++ show substs) $ vcat gs)

    genGuard  :: Guard -> Asm Doc
    genGuard (Guard t expr)
      = do (testE) <- genExpr t
           exprSt          <- genExpr expr
           return $ if isExprTrue t
                      then exprSt
                      else notImplemented $ text "if" <+> parens testE <.> block exprSt

    -- | Generates a list of boolish expression for matching the pattern
    genTest :: Name -> (Doc, Pattern) -> Asm ([ConditionDoc], [(TName, Doc)])
    genTest modName (scrutinee,pattern)
      = case pattern of
              PatWild -> return $ ([], [])
              PatVar tn pat
                -> do (conds, substs) <- genTest modName (scrutinee,pat)
                      return (conds, (tn, scrutinee):substs)
              PatLit (LitInt i)
                -> return ([ifEqInt scrutinee (text (show i))], [])
              PatLit lit@(LitString _)
                -> let tmp = var (str "tmp") (tpe "Int") in
                   return ([(\thn els -> obj [ "op" .= str "Primitive"
                                    , "name" .= str "infixEq(String, String): Boolean"
                                    , "args" .= list [scrutinee, ppLit lit]
                                    , "returns" .= list [tmp]
                                    , "rest" .= ifEqInt tmp (text "1") thn els
                                    ])
                   ], [])
              PatCon tn fields repr _ _ _ info skip  --TODO: skip test ?
                | getName tn == nameTrue
                -> return ([ifEqInt scrutinee (text "1")], [])
                | getName tn == nameFalse
                -> return ([ifEqInt scrutinee (text "0")], [])
                | otherwise
                -> case repr of
                     -- special
                     ConEnum _ _ _ tag
                       -> return ([ifEqInt scrutinee (int tag)], [])
--                      ConSingleton{}
--                        | getName tn == nameOptionalNone
--                        -> [ifNull scrutinee]
--                      ConSingleton _ DataStructAsMaybe _ _
--                        -> [ifNull scrutinee] -- <+> ppName (getName tn)]
--                      ConSingleton _ DataAsMaybe _ _
--                        -> [ifNull scrutinee] -- <+> ppName (getName tn)]
--                      ConSingleton _ DataAsList _ _
--                        -> [ifNull scrutinee] -- <+> ppName (getName tn)]
                     _ -> do fieldNames  <- (mapM (\(n,t) -> do x <- genVarName (asString $ ppName n)
                                                                return $ var x (transformType t)) (conInfoParams info))
                             let conTest = ifCon scrutinee (getConTypeTag info) (str $ show $ conInfoName info) fieldNames
                             (fieldTests, subfieldSubsts)  <- (bimap concat concat) . unzip <$> mapM
                                             (\(field,fieldName) -> genTest modName (debugWrap ("genTest: normal: " ++ show field ++ " -> " ++ show fieldName) fieldName, field) )
                                             ( zip fields fieldNames )
                             -- let fieldSubsts = zipWith (\(n,t) x -> (TName n t, x)) 
                             --                    (conInfoParams info) fieldNames
                             return ((conTest:fieldTests), subfieldSubsts) -- ++ fieldSubsts)

    ifEqInt :: Doc -> Doc -> ConditionDoc
    ifEqInt scrutinee lit thn els = obj [ "op" .= str "Switch"
                                        , "scrutinee" .= scrutinee
                                        , "cases" .= list [obj ["value" .= lit, "then" .= thn ]]
                                        , "default" .= els
                                        ]

    ifNull :: Doc -> ConditionDoc
    ifNull scrutinee thn els = let tmp = var (str "tmp") (tpe "Int") in 
                               obj [ "op" .= str "Primitive" 
                                   , "name" .= str "ptr_eq"
                                   , "args" .= list [scrutinee, var (text "-1") (tpe "Ptr")]
                                   , "returns" .= list [tmp]
                                   , "rest" .= ifEqInt tmp (text "1") thn els
                                   ]

    ifCon :: Doc -> Doc -> Doc -> [Doc] -> ConditionDoc
    ifCon scrutinee tpt t fields thn els = debugWrap ("ifCon@" ++ asString scrutinee ++ ": " ++ asString tpt ++ "." ++ asString t ++ "(" ++ asString (tupled fields) ++ ")")
                                         $ obj [ "op" .= str "Match"
                                               , "scrutinee" .= scrutinee
                                               , "type_tag" .= tpt
                                               , "clauses" .= list [obj ["tag" .= t, "params" .= list fields, "body" .= thn]]
                                               , "default_clause" .= obj ["params" .= list [], "body" .= els]
                                               ]

    -- | Takes a list of docs and concatenates them with logical and
    conjunction :: [ConditionDoc] -> ConditionDoc
    conjunction []
      = \thn els -> thn
    conjunction (doc:docs)
      = \thn els -> doc ((conjunction docs) thn els) els

---------------------------------------------------------------------------------
-- Expressions that produce statements on their way
---------------------------------------------------------------------------------

-- | Generates javascript statements and a javascript expression from core expression
genExpr :: Expr -> Asm Doc
genExpr expr
  = -- trace ("genExpr: " ++ show expr) $
    case expr of
     -- check whether the expression is pure an can be inlined
     _  | isInlineableExpr expr -> genInline expr

     TypeApp e _ -> genExpr e
     TypeLam _ e -> genExpr e

     -- handle not inlineable cases
     App (TypeApp (Con name repr) _) [arg]  | getName name == nameOptional || isConIso repr
       -> genExpr arg
     App (Con _ repr) [arg]  | isConIso repr
       -> genExpr arg
     App (Var tname _) [Lit (LitInt i)]
       -> return $ obj [ "op" .= str "Literal", "type" .= str "Int", "value" .= pretty i ]

     -- special: .cctx-field-addr-of: create a tuple with the object and the field name as a string
     App (TypeApp (Var cfieldOf _) [_]) [Var con _, Lit (LitString conName), Lit (LitString fieldName)]  | getName cfieldOf == nameFieldAddrOf
       -> do conDoc <- genTName con
             return $ notImplemented (text "{obj:" <+> conDoc <.> text ", field_name: \"" <.> ppName (unqualify (readQualified fieldName)) <.> text "\"}")

     App f args
       -> case extractList expr of
                  Just (xs,tl) -> genList xs tl
                  Nothing -> case extractExtern f of
                   Just (tname,formats)
                     -> case args of
                         [Lit (LitInt i)] | getName tname == nameByte  && i >= 0 && i < 256
                           -> return (pretty i)
                         [Lit (LitInt i)] | getName tname `elem` [nameInt32,nameSSizeT,nameInternalInt32,nameInternalSSizeT]  && isSmallInt i
                           -> return (pretty i)
                         [Lit (LitInt i)] | getName tname `elem` [nameInt64,nameIntPtrT]  && isSmallInt i
                           -> return (pretty i <.> text "n")
                         _ -> -- genInlineExternal tname formats argDocs
                              do (argDocs) <- genExprs args
                                 (doc) <- genExprExternal tname formats argDocs
                                 if (getName tname == nameReturn)
                                  then return (text "")
                                  else return (doc)
                   Nothing
                    -> do lsDecls <- genExprs (f:trimOptionalArgs args)
                          let (fdoc:docs) = lsDecls
                          return $ obj [ "op" .= str "App"
                                       , "fn" .= fdoc
                                       , "args" .= list docs
                                       ]

     Let groups body
       -> do decls1       <- genGroups False groups
             (doc) <- genExpr body
             return $ obj [ "op" .= str "Let"
                          , "definitions" .= list decls1
                          , "body".= doc
                          ]

     Case _ _
       -> do (doc, tname) <- genVarBinding expr
             nameDoc <- genTName tname
             return $ notImplemented $ text "Case" -- (doc, nameDoc)

     _ -> failure ("JavaScript.FromCore.genExpr: invalid expression:\n" ++ show expr)

extractList :: Expr -> Maybe ([Expr],Expr)
extractList e
  = let (elems,tl) = extract [] e
    in if (length elems > 10) -- only use inlined array for larger lists
        then Just (elems,tl)
        else Nothing
  where
    extract acc expr
      = case expr of
          App (TypeApp (Con name info) _) [hd,tl]  | getName name == nameCons
            -> extract (hd:acc) tl
          _ -> (reverse acc, expr)

genList :: [Expr] -> Expr -> Asm Doc
genList elems tl
  = do (docs) <- genExprs elems
       (tdoc) <- genExpr tl
       return (text "$std_core_vector.vlist" <.> tupled [list docs, tdoc])

{-
genExternalExpr :: TName -> String -> [Expr] -> Asm (Doc,Doc)
genExternalExpr tname format args
  | getName tname == nameReturn
  = do (statDoc,exprDoc) <- genExpr (head args)
       return (statDoc <-> text "return" <+> exprDoc <.> semi <.> debugComment "premature return statement (2)"
              , text "") -- emptyness of doc is important! no other way to tell to not generate assignment/return/whatever!
  | otherwise
  = do (statDocs,argDocs) <- genExprs args
       doc <- genExternal tname format argDocs
       return ( debugComment "<genExternalExpr.stmt>" <.> vcat statDocs <.> debugComment "</genExternalExpr.stmt>"
              , debugComment "<genExternalExpr.expr>" <.> doc           <.> debugComment "</genExternalExpr.expr>"
              )
-}

genExprs :: [Expr] -> Asm [Doc]
genExprs exprs = mapM genExpr exprs

-- | Introduces an additional let binding in core if necessary
--   The expression in the result is guaranteed to be a Var afterwards
genVarBinding :: Expr -> Asm ([Doc], TName)
genVarBinding expr
  = case expr of
      Var tn _ -> return $ ([], tn)
      _        -> do name <- newVarName "x"
                     let tp = typeOf expr
                     val <- genExpr expr
                     let defs  = [def (var (str $ show name) (transformType tp)) val]
                     return ( defs, TName name (typeOf expr) )

---------------------------------------------------------------------------------
-- Pure expressions
---------------------------------------------------------------------------------

genPure   :: Expr -> Asm Doc
genPure expr
  = case expr of
     TypeApp e _ -> genPure e
     TypeLam _ e -> genPure e
     Var name (InfoExternal formats)
       -> genWrapExternal name formats  -- unapplied inlined external: wrap as function
     Var name info
       -> asVar name -- genTName name
     Con name repr | getName name == nameUnit
       -> return $ obj [ "op" .= str "Literal", "type" .= transformType (tnameType name) ]
     Con name repr | getName name == nameTrue
       -> return $ obj [ "op" .= str "Literal", "value" .= text "1", "type" .= transformType (tnameType name) ]
     Con name repr | getName name == nameFalse
       -> return $ obj [ "op" .= str "Literal", "value" .= text "0", "type" .= transformType (tnameType name) ]
     Con name repr
       -> asVar name
     Lit l
       -> return $ ppLit l
     Lam params eff body
       -> do args <- mapM asVar params
             bodyDoc <- genStat (ResultReturn Nothing params) body
             return $ obj [ "op" .= str "Abs"
                          , "params" .= list args
                          , "body" .= bodyDoc
                          ]
     _ -> failure ("JavaScript.FromCore.genPure: invalid expression:\n" ++ show expr)

isPat :: Bool -> Pattern -> Bool
isPat b q
  = case q of
      PatWild     -> False
      PatLit _    -> False
      PatVar _ q' -> isPat b q'
      PatCon {}   -> getName (patConName q) == if b then nameTrue else nameFalse

-- | Generates an effect-free javasript expression
--   NOTE: Throws an error if expression is not guaranteed to be effectfree
genInline :: Expr -> Asm Doc
genInline expr
  = case expr of
      _  | isPureExpr expr -> genPure expr
      TypeLam _ e -> genInline e
      TypeApp e _ -> genInline e
      App (TypeApp (Con name repr) _) [arg]  | getName name == nameOptional || isConIso repr
        -> genInline arg
      App (Con _ repr) [arg]  | isConIso repr
        -> genInline arg
      App f args
        -> do argDocs <- mapM genInline (trimOptionalArgs args)
              case extractExtern f of
                Just (tname,formats)
                  -> case args of
                       [Lit (LitInt i)] | getName tname `elem` [nameInt32,nameSSizeT,nameInternalInt32,nameInternalSSizeT] && isSmallInt i
                         -> return (pretty i)
                       [Lit (LitInt i)] | getName tname `elem` [nameInt64,nameIntPtrT] && isSmallInt i
                         -> return $ notImplemented $ (pretty i <.> text "n")
                       _ -> genInlineExternal tname formats argDocs
                Nothing
                  -> case (f,args) of
                       ((Var tname _),[Lit (LitInt i)]) | getName tname `elem` [nameInt32,nameSSizeT,nameInternalInt32,nameInternalSSizeT] && isSmallInt i
                         -> return (pretty i)
                       ((Var tname _),[Lit (LitInt i)]) | getName tname `elem` [nameInt64,nameIntPtrT] && isSmallInt i
                         -> return (pretty i <.> text "n")
                       _ -> do fdoc <- genInline f
                               return $ notImplemented $ (fdoc <.> tupled argDocs)

      _ -> failure ("JavaScript.FromCore.genInline: invalid expression:\n" ++ show expr)

extractExtern :: Expr -> Maybe (TName,[(Target,String)])
extractExtern expr
  = case expr of
      TypeApp (Var tname (InfoExternal formats)) targs -> Just (tname,formats)
      Var tname (InfoExternal formats) -> Just (tname,formats)
      _ -> Nothing

-- not fully applied external gets wrapped in a function
genWrapExternal :: TName -> [(Target,String)] -> Asm Doc
genWrapExternal tname formats
  = do let n = snd (getTypeArities (typeOf tname))
       vs  <- genVarNames n
       (doc) <- genExprExternal tname formats vs
       return $ notImplemented $ parens (text "function" <.> tupled vs <+> block (vcat ([text "return" <+> doc <.> semi])))

-- inlined external sometimes  needs wrapping in a applied function block
genInlineExternal :: TName -> [(Target,String)] -> [Doc] -> Asm Doc
genInlineExternal tname formats argDocs = genExprExternal tname formats argDocs

-- generate external: needs to add try blocks for primitives that can throw exceptions
genExprExternal :: TName -> [(Target,String)] -> [Doc] -> Asm (Doc)
genExprExternal tname formats argDocs0
  = do (doc) <- genExprExternalPrim tname formats argDocs0
       case splitFunType (typeOf tname) of
         Nothing -> return (doc)
         Just (pars,eff,res)
           -> let (ls,tl) = extractOrderedEffect eff
              in case filter (\l -> labelName l == nameTpPartial) ls of
                   [] -> return (doc)
                   _  -> -- has an exception type, wrap it in a try handler
                         let try = parens $
                                   parens (text "function()" <+> block (vcat (
                                     [text "try" <+> block (vcat ([text "return" <+> doc <.> semi]))
                                     ,text "catch(_err){ return $std_core._throw_exception(_err); }"]
                                     )))
                                   <.> text "()"
                         in return $ notImplemented (try)

-- special case: .cctx-hole-create
genExprExternalPrim :: TName -> [(Target,String)] -> [Doc] -> Asm (Doc)
genExprExternalPrim tname formats [] | getName tname == nameCCtxHoleCreate
  = return (text "undefined")

{-
-- special case: cfield-set (field is implemented as {value:<obj>, field:<string>})
genExprExternalPrim tname formats [accDoc,resDoc] | getName tname == nameCFieldSet
  = return ([], tupled [accDoc <.> text ".value[" <.> accDoc <.> text ".field] =" <+> resDoc, text "$std_core_types._Unit_"])
-}

-- normal external
genExprExternalPrim tname formats argDocs0
  = let name = getName tname
        format = getFormat tname formats
    in return $ (case (tnameType tname) of 
      TFun _ _ t -> appPrim format argDocs0 (transformType t)
      _ -> notImplemented $ text "Primitive non-function")

getFormat :: TName -> [(Target,String)] -> String
getFormat tname formats
  = case lookupTarget VM formats of  -- TODO: pass specific target from the flags
      Nothing -> -- failure ("backend does not support external in " ++ show tname ++ ": " ++ show formats)
                 trace( "warning: backend does not support external in " ++ show tname ) $
                    ("undefined external: " ++ (show tname))
      Just s -> s

genDefName :: TName -> Asm Doc
genDefName tname
  = return (ppName (unqualify (getName tname)))

genTName :: TName -> Asm Doc
genTName tname
  = do env <- getEnv
       case lookup tname (substEnv env) of
          Nothing -> genName (getName tname)
          Just d  -> return d

genName :: Name -> Asm Doc
genName name
  = if (isQualified name)
      then do modname <- getModule
              if (qualifier name == modname)
               then return (ppName (unqualify name))
               else return (ppName name)
      else return (ppName name)

genVarName :: String -> Asm Doc
genVarName s = do n <- newVarName s
                  return $ ppName n

-- | Generates `i` fresh variables and delivers them as `Doc` right away
genVarNames :: Int -> Asm [Doc]
genVarNames i = do ns <- newVarNames i
                   return $ map ppName ns

-- | Generate a name with its type in comments
genCommentTName :: TName -> Asm Doc
genCommentTName (TName n t)
  = do env <- getPrettyEnv
       return $ ppName n <+> comment (Pretty.ppType env t )

trimOptionalArgs args
  = reverse (dropWhile isOptionalNone (reverse args))
  where
    isOptionalNone arg
      = case arg of
          TypeApp (Con tname _) _ -> getName tname == nameOptionalNone
          _ -> False

---------------------------------------------------------------------------------
-- Classification
---------------------------------------------------------------------------------

extractExternal  :: Expr -> Maybe (TName, String, [Expr])
extractExternal expr
  = case expr of
      App (TypeApp (Var tname (InfoExternal formats)) targs) args
        -> Just (tname, format tname formats, args)
      App var@(Var tname (InfoExternal formats)) args
        -> Just (tname, format tname formats, args)
      _ -> Nothing
  where
    format tn fs
      = case lookupTarget (JS JsDefault) fs of  -- TODO: pass real target from flags
          Nothing -> failure ("backend does not support external in " ++ show tn ++ show fs)
          Just s -> s

isFunExpr :: Expr -> Bool
isFunExpr expr
  = case expr of
      TypeApp e _   -> isFunExpr e
      TypeLam _ e   -> isFunExpr e
      Lam args eff body -> True
      _                 -> False

isInlineableExpr :: Expr -> Bool
isInlineableExpr expr
  = case expr of
      TypeApp expr _   -> isInlineableExpr expr
      TypeLam _ expr   -> isInlineableExpr expr
      App (Var _ (InfoExternal _)) args -> all isPureExpr args
      {-
      -- TODO: comment out for now as it may prevent a tailcall if inlined
      App f args       -> -- trace ("isInlineable f: " ++ show f) $
                          isPureExpr f && all isPureExpr args
                          -- all isInlineableExpr (f:args)
                          && not (isFunExpr f) -- avoid `fun() {}(a,b,c)` !
                          -- && getParamArityExpr f == length args
      -}
      _                -> isPureExpr expr

isPureExpr :: Expr -> Bool
isPureExpr expr
  = case expr of
      TypeApp expr _  -> isPureExpr expr
      TypeLam _ expr  -> isPureExpr expr
      Var n (InfoConField{}) -> False
      Var n _  | getName n == nameReturn -> False -- make sure return will never be inlined
               | otherwise               -> True
      Con _ _ -> True
      Lit _   -> True
      Lam _ _ _ -> True
      _       -> False


isTailCalling :: Expr -> Name -> Bool
isTailCalling expr n
  = case expr of
      TypeApp expr _    -> expr `isTailCalling` n     -- trivial
      TypeLam _ expr    -> expr `isTailCalling` n     -- trivial
      Lam _ _ _           -> False                      -- lambda body is a new context, can't tailcall
      Var _ _           -> False                      -- a variable is not a call
      Con _ _           -> False                      -- a constructor is not a call
      Lit _             -> False                      -- a literal is not a call
      App (Var tn info) args   | getName tn == n            -- direct application can be a tail call
                        -> infoArity info == length args
      App (TypeApp (Var tn info) _) args | getName tn == n  -- tailcalled function might be polymorphic and is applied to types before
                        -> infoArity info == length args
      App (Var tn _) [e] | getName tn == nameReturn   -- a return statement is transparent in terms of tail calling
                        -> e `isTailCalling` n
      App _ _           -> False                      -- other applications don't apply
      Let _ e           -> e `isTailCalling` n        -- tail calls can only happen in the actual body
      Case _ bs         -> any f1 bs                  -- match statement get analyzed in depth
  where
    f1 (Branch _ gs) = any f2 gs                      -- does any of the guards tailcall?
    f2 (Guard _ e)   = e `isTailCalling` n            -- does the guarded expression tailcall?

---------------------------------------------------------------------------------
-- The assembly monad
---------------------------------------------------------------------------------

newtype Asm a = Asm { unAsm :: Env -> St -> (a, St)}

instance Functor Asm where
  fmap f (Asm a) = Asm (\env st -> case a env st of
                                     (x,st') -> (f x, st'))

instance Applicative Asm where
  pure x = Asm (\env st -> (x,st))
  (<*>)  = ap

instance Monad Asm where
  -- return = pure
  (Asm a) >>= f = Asm (\env st -> case a env st of
                                    (x,st1) -> case f x of
                                                 Asm b -> b env st1)
instance F.MonadFail Asm where
  fail = failure

runAsm :: Env -> Asm Doc -> Doc
runAsm initEnv (Asm asm)
  = case asm initEnv initSt of
      (doc,st) -> doc

data St  = St  { uniq     :: Int
               }

data Env = Env { moduleName        :: Name                    -- | current module
               , prettyEnv         :: Pretty.Env              -- | for printing nice types
               , substEnv          :: [(TName, Doc)]          -- | substituting names
               , inStatement       :: Bool                    -- | for generating correct function declarations in strict mode
               }

data Result = ResultReturn (Maybe Name) [TName] -- first field carries function name if not anonymous and second the arguments which are always known
            | ResultAssign Name (Maybe Name)    -- variable name and optional label to break

initSt = St 0

instance HasUnique Asm where
  updateUnique f
    = Asm (\env st -> (uniq st, st{ uniq = f (uniq st)}))

updateSt f
  = Asm (\env st -> (st,f st))

getSt
  = updateSt id

setSt st
  = updateSt (const st)

getEnv
  = Asm (\env st -> (env, st))

withEnv f (Asm asm)
  = Asm (\env st -> asm (f env) st)

localUnique asm
  = do u <- updateUnique id
       x <- asm
       setUnique u
       return x

newVarName :: String -> Asm Name
newVarName s
  = do u <- unique
       return (newName ("@" ++ s ++ show u))

newVarNames :: Int -> Asm [Name]
newVarNames 0 = return []
newVarNames i
  = do n  <- newVarName "x"
       ns <- newVarNames (i - 1)
       return (n:ns)

getModule :: Asm Name
getModule
  = do env <- getEnv
       return (moduleName env)

getPrettyEnv :: Asm Pretty.Env
getPrettyEnv
  = do env <- getEnv
       return (prettyEnv env)

withTypeVars :: [TypeVar] -> Asm a -> Asm a
withTypeVars vars asm
  = withEnv (\env -> env{ prettyEnv = Pretty.niceEnv (prettyEnv env) vars }) asm

withNameSubstitutions :: [(TName, Doc)] -> Asm a -> Asm a
withNameSubstitutions subs asm
  = withEnv (\env -> env{ substEnv = subs ++ substEnv env }) asm

withStatement :: Asm a -> Asm a
withStatement asm
  = withEnv (\env -> env{ inStatement = True }) asm

getInStatement :: Asm Bool
getInStatement
  = do env <- getEnv
       return (inStatement env)

---------------------------------------------------------------------------------
-- Pretty printing
---------------------------------------------------------------------------------


ppLit :: Lit -> Doc
ppLit lit
    = case lit of
      LitInt i    -> obj [ "op" .= str "Literal", "type" .= tpe "Int", "value" .= pretty i ]
      LitChar c   -> notImplemented $ text ("0x" ++ showHex 4 (fromEnum c))
      LitFloat d  -> notImplemented $ text (showsPrec 20 d "")
      LitString s -> obj [ "op" .= str "Literal", "type" .= tpe "String", "value" .= dquotes (hcat (map escape s)) ]
    where
      escape c
        = if (c < ' ')
           then (if (c=='\n') then text "\\n"
                 else if (c == '\r') then text "\\r"
                 else if (c == '\t') then text "\\t"
                 else text "\\u" <.> text (showHex 4 (fromEnum c)))
          else if (c <= '~')
           then (if (c == '\"') then text "\\\""
                 else if (c=='\'') then text "\\'"
                 else if (c=='\\') then text "\\\\"
                 else char c)
          else if (fromEnum c <= 0xFFFF)
           then text "\\u" <.> text (showHex 4 (fromEnum c))
          else if (fromEnum c > 0x10FFFF)
           then text "\\uFFFD"  -- error instead?
           else let code = fromEnum c - 0x10000
                    hi = (code `div` 0x0400) + 0xD800
                    lo = (code `mod` 0x0400) + 0xDC00
                in text ("\\u" ++ showHex 4 hi ++ "\\u" ++ showHex 4 lo)

isSmallLitInt expr
  = case expr of
      Lit (LitInt i)  -> isSmallInt i
      _ -> False

isSmallInt i = (i > minSmallInt && i < maxSmallInt)

maxSmallInt, minSmallInt :: Integer
maxSmallInt = 9007199254740991  -- 2^53 - 1
minSmallInt = -maxSmallInt

ppName :: Name -> Doc
ppName name
  = quoted $ if isQualified name
     then ppModName (qualifier name) <.> dot <.> encode False (unqualify name)
     else encode False name

ppQName :: Name -> Name -> Doc
ppQName modName name
  = if (modName == qualifier name)   -- We need to qualify always since otherwise we may clash with local variables. i.e. fun f( x : int ) { Main.x( x ) }
     then ppName (unqualify name)
     else ppName name

ppModName :: Name -> Doc
ppModName name
  = text "$" <.> encode True (name)

encode :: Bool -> Name -> Doc
encode isModule name
  = text $ asciiEncode isModule $ show name

block :: Doc -> Doc
block doc
  = text "{" <--> tab doc <--> text "}"


tcoBlock :: Doc -> Doc
tcoBlock doc
  = text "{ tailcall: while(1)" <->
    text "{" <--> tab ( doc ) <--> text "}}"

tailcall :: Doc
tailcall  = text "continue tailcall;"

object :: [(Doc, Doc)] -> Doc
object xs
  = text "{" <+> hcat ( punctuate (comma <.> space) (map f xs) ) <+> text "}"
  where
    f (d1, d2) = d1 <.> colon <+> d2

tab :: Doc -> Doc
tab doc
  = indent 2 doc

typeComment = comment

comment :: Doc -> Doc
comment d
  = text "/*" <+> d <+> text "*/ "

linecomment :: Doc -> Doc
linecomment d
  = text "//" <+> d

debugComment :: String -> Doc
debugComment s
  = if debug
      then comment (text s)
      else empty

debugWrap     :: String -> Doc -> Doc
debugWrap s d
  = if debug then obj [
    "op" .= str "DebugWrap",
    "inner" .= d,
    "annotation" .= str s
  ] else d

tagField :: Doc
tagField  = text "_tag"

constdecl :: Doc
constdecl = text "const"

quoted :: Doc -> Doc
quoted d = text $ show $ asString d

str :: String -> Doc
str s = text $ show $ s

obj :: [Doc] -> Doc
obj = encloseSep lbrace rbrace comma

(.=) :: String -> Doc -> Doc
(.=) k v = text (show k ++ ":") <+> v

--------------------------------------------------------------------------------
-- Smart-constructors for instructions
--------------------------------------------------------------------------------
app :: Doc -> [Doc] -> Doc
app fn args = obj [ "op" .= text "\"App\""
                  , "fn" .= fn
                  , "args" .= list args
                  ]

primitive :: [Doc] -> String -> [Doc] -> Doc -> Doc
primitive outs name ins body = obj
  [ "op" .= str "Primitive"
  , "name" .= str name
  , "args" .= list ins
  , "returns" .= list outs
  , "rest" .= body
  ]

-- | Simplified primitive smart-constructor (works almost like function application)
appPrim :: String -- ^ name
        -> [Doc]  -- ^ args
        -> Doc    -- ^ return type
        -> Doc
appPrim name args tp = primitive [var (str "primitive_result") tp] name args (var (str "primitive_result") tp)

-- | Pseudo-instruction for not-yet supported parts
notImplemented :: Doc -> Doc
notImplemented doc = appPrim ("Not implemented: " ++ show (asString doc)) [] (tpe "Unit")

-- TODO other instructions

var :: Doc -> Doc -> Doc
var x t = obj [ "op" .= str "Var", "id" .= x, "type" .= t ]
asVar :: TName -> Asm Doc
asVar n = do env <- getEnv
             case lookup n (substEnv env) of
                Nothing -> return $ var (str $ show $ getName n) (transformType $ tnameType n)
                Just s -> return s

---- Types
tFn :: String -> [Doc] -> Doc -> Doc
tFn pur ps r = obj [ "op" .= text (show "Function")
                   , "params" .= list ps
                   , "return" .= r
                   , "purity" .= text (show pur)
                   ]

-- | Simple named type
tpe :: String -> Doc
tpe name = obj [ "op" .= text (show name) ]

---- Other forms

-- | Definitions
def :: Doc -> Doc -> Doc
def n v = obj [ "name" .= n, "value" .= v ]
