-----------------------------------------------------------------------------
-- Copyright 2012-2021, Microsoft Research, Daan Leijen, Edsko de Vries.
--
-- This is free software; you can redistribute it and/or modify it under the
-- terms of the Apache License, Version 2.0. A copy of the License can be
-- found in the LICENSE file at the root of this distribution.
-----------------------------------------------------------------------------

module Backend.VM.FromCore
      ( vmFromCore )
 where

import Platform.Config(version)
import Lib.Trace
import Control.Applicative hiding (empty)
import Control.Monad
import qualified Control.Monad.Fail as F
import Data.List ( intersperse, partition, nub )
import Data.Char
import Data.Bifunctor (bimap)

import qualified Data.Set as S

import Type.Type
import qualified Type.Pretty as Pretty

import Lib.PPrint
import Common.Name
import Common.NamePrim
import Common.Failure
import Common.Unique
import Common.Syntax

import Core.Core
import Core.Pretty
import Core.CoreVar

type ConditionDoc = Doc -> Doc -- `cd thn` gets you the doc; expects to be in an alternative-choice

debug :: Bool
debug  = True

externalNames :: [(TName, Doc)]
externalNames
  = [ (conName exprTrue,  text "true")
    , (conName exprFalse, text "false")
    , (TName nameOptionalNone typeOptional, text "undefined")  -- ugly but has real performance benefit
    ]

--------------------------------------------------------------------------
-- Generate JavaScript code from System-F core language
--------------------------------------------------------------------------

vmFromCore :: BuildType -> Maybe (Name,Bool) -> [Import] -> Core -> Doc
vmFromCore buildType mbMain imports core
  = runAsm (Env moduleName penv externalNames) (genModule buildType mbMain imports core)
  where
    moduleName = coreProgName core
    penv       = Pretty.defaultEnv{ Pretty.context = moduleName, Pretty.fullNames = False }

genModule :: BuildType -> Maybe (Name,Bool) -> [Import] -> Core -> Asm Doc
genModule buildType mbMain imports core
  =  do impdecls <- genLoadLibs imports
        decls0 <- genGroups True (coreProgDefs core)
        decls1 <- genTypeDefs (coreProgTypeDefs core)
        let -- `imports = coreProgImports core` is not enough due to inlined definitions
            (mainEntry) = case mbMain of
                          Nothing -> appPrim "is a library" [] (tpe "Unit")
                          Just (name,isAsync)
                            -> app (var (str $ show name) (tFn "Effectful" [] (tpe "Unit"))) []
        return $
                    obj
                    [ "metadata" .= 
                      obj [ "generated by" .= str "Koka"
                          , "koka version" .= str version
                          , "program name" .= str (show (coreProgName core))
                          ]
                    , "definitions" .=
                      list (impdecls 
                           ++ decls0 
                           ++ decls1
                           )
                    , "main" .= mainEntry
                    ]

---------------------------------------------------------------------------------
-- Generate import definitions
---------------------------------------------------------------------------------
libName imp = (var (str ("import$" ++ imp)) (tpe "Ptr"))
genLoadLibs :: [Import] -> Asm [Doc]
genLoadLibs imports = return $ map genLoadLib imports
  where genLoadLib imp = let name = (if null (importPackage imp) then "." else importPackage imp) ++ "/" ++ (moduleNameToPath  (importName imp)) in
          def (libName (show $ importName imp))
            (obj [ "op" .= str "LoadLib"
                 , "path" .= obj [ "op" .= str "Literal", "type" .= tpe "String", "format" .= str "path", "value" .=  str ("$0/" ++ name ++ ".rpyeffect")]
                 ])
---------------------------------------------------------------------------------
-- Translate types
---------------------------------------------------------------------------------
transformType :: Type -> Doc
transformType (TVar _) = tpe "Ptr" -- erased
transformType (TForall _ _ t) = transformType t -- TODO do we need to thunk
transformType (TFun ps e t) = obj [ "op" .= str "Function"
                                  , "params" .= list [ transformType pt | (_,pt) <- ps]
                                  , "return" .= transformType t
                                  , "purity" .= str "Effectful" -- TODO infer from e
                                  ]
transformType (TCon c) | nameModule (typeConName c) == "std/core/types" = case (nameStem (typeConName c)) of 
  "unit" -> tpe "Unit" 
  "string" -> tpe "String"
  "bool" -> tpe "Int"
  "int" -> tpe "Int"
  t -> obj [ "op" .= str "Ptr", "extern_ptr_name" .= (str $ show t) ]
transformType (TCon c) = obj [ "op" .= str "Ptr", "extern_ptr_name" .= (str $ show $ typeConName c) ]
transformType (TApp t as) = transformType t
transformType (TSyn _ _ t) = transformType t

---------------------------------------------------------------------------------
-- Generate mcore statements for value definitions
---------------------------------------------------------------------------------

genGroups :: Bool -> [DefGroup] -> Asm [Doc]
genGroups topLevel groups
  = localUnique $ concat <$> mapM (genGroup topLevel) groups

genGroup :: Bool -> DefGroup -> Asm [Doc]
genGroup topLevel group
  = case group of
      DefRec defs   -> mapM (genDef topLevel) defs
      DefNonRec def -> (:[]) <$> genDef topLevel def

genDef :: Bool -> Def -> Asm Doc
genDef topLevel (Def name tp expr vis sort inl rng comm)
  = do let n = var (str $ show name) (transformType tp)
       v <- genExpr expr
       return $ def n v 

---------------------------------------------------------------------------------
-- Generate value constructors for each defined type
---------------------------------------------------------------------------------

genTypeDefs :: TypeDefGroups -> Asm [Doc]
genTypeDefs groups
  = concat <$> mapM (genTypeDefGroup) groups

genTypeDefGroup :: TypeDefGroup -> Asm [Doc]
genTypeDefGroup (TypeDefGroup tds)
  = concat <$> mapM (genTypeDef) tds

genTypeDef ::TypeDef -> Asm [Doc]
genTypeDef  (Synonym {})
  = return []
genTypeDef (Data info isExtend)
  = do modName <- getModule
       let (dataRepr, conReprs) = getDataRepr info
       mapM ( \(c,repr)  ->
          do let args = map (\(n,t) -> var (ppName n) (transformType t)) (conInfoParams c)
             let name = str $ show (conInfoName c)
             let tp = transformType $ conInfoType c
             penv <- getPrettyEnv
             let singletonValue val = def (var name (transformType (conInfoType c))) val
             if (conInfoName c == nameTrue)
             then return $ obj [ "op" .= str "Literal", "type" .= str "Int", "value" .= text "1" ]
             else if (conInfoName c == nameFalse)
             then return $ obj [ "op" .= str "Literal", "type" .= str "Int", "value" .= text "0" ]
             else return $ case repr of
                        -- special
                        ConEnum{}
                          -> debugWrap ("enum ") $ obj ["op" .= str "Literal", "type" .= str "Int", "value" .= int (conTag repr)]
--                         ConSingleton{} | conInfoName c == nameOptionalNone
--                           -> null
--                         ConSingleton _ DataStructAsMaybe _ _
--                           -> null
--                         ConSingleton _ DataAsMaybe _ _
--                           -> null
--                         ConSingleton _ DataAsList _ _
--                           -> null
                        -- normal
                        _            -> genConstr penv c repr name tp args
          ) $ zip (dataInfoConstrs $ info) conReprs
  where
    null = var (text "-1") (tpe "Ptr")
    genConstr penv c repr name tp args
      = def (var name tp) (debugWrap "genConstr" $
             obj [ "op" .= str "Abs", "params" .= list args
                 , "body" .= obj [ "op" .= str "Construct"
                                 , "type_tag" .= (getConTypeTag c)
                                 , "tag" .= name
                                 , "args" .= list args
                                 ]
                 ])

getConTypeTag info = getReturn $ conInfoType info
  where 
    getReturn (TFun _ _ r) = str $ show $ r
    getReturn (TForall _ _ t) = getReturn t
    getReturn t = error $ "Constructor does not have a function type: " ++ show t
getConTag modName coninfo repr
  = case repr of
      ConOpen{} -> -- ppLit (LitString (show (openConTag (conInfoName coninfo))))
                   let name = toOpenTagName (conInfoName coninfo)
                   in ppName (if (qualifier name == modName) then unqualify name else name)
      _ -> int (conTag repr)

openConTag name
  = name

---------------------------------------------------------------------------------
-- Statements
---------------------------------------------------------------------------------

-- | Generates a statement from an expression by applying a return context (deeply) inside

genExprStat expr
  = case expr of
      -- If expression is inlineable, inline it
      _  | isInlineableExpr expr
        -> do exprDoc <- genInline expr
              return exprDoc

      Case exprs branches
         -> do (defss, scrutinees) <-  unzip <$> mapM (\e-> if isInlineableExpr e && isTypeBool (typeOf e)
                                                               then do d       <- genInline e
                                                                       return ([], d)
                                                               else do (sd,vn) <- genVarBinding e
                                                                       vd <- asVar vn
                                                                       return (sd, vd)
                                                       ) exprs
               doc                <- genMatch scrutinees branches
               return $ obj [ "op" .= str "LetRec"
                            , "definitions" .= list (concat defss)
                            , "body" .= doc
                            ]

      Let groups body
        -> do defs <- genGroups False groups
              body <- genExprStat body
              return $ obj [ "op" .= str "LetRec"
                           , "definitions" .= list defs
                           , "body" .= body
                           ]

      -- Handling all other cases
      _ -> do (exprDoc) <- genExpr expr
              return exprDoc

-- | Generates a statement for a match expression regarding a given return context
genMatch :: [Doc] -> [Branch] -> Asm Doc
genMatch scrutinees branches
  = fmap (debugWrap "genMatch") $ do
    case branches of
        []  -> fail ("Backend.VM.FromCore.genMatch: no branch in match statement: " ++ show(scrutinees))
        [b] -> do (conds, d) <- genBranch scrutinees b
                  return $ debugWrap "genMatch: one case" $ obj [ "op" .= str "AlternativeChoice"
                      , "choices" .= list [(conjunction conds) d, (appPrim "non-exhaustive match" [] (tpe "Bottom"))]
                      ]

        bs
           | all (\b-> length (branchGuards   b) == 1) bs
          && all (\b->isExprTrue $ guardTest $ head $ branchGuards b) bs
          -> do xs <- mapM (genBranch scrutinees) bs
                let bs = map (\(conds,d) -> (conjunction conds d)) xs
                return $ debugWrap "genMatch: guard-free case"
                       $ obj [ "op" .= str "AlternativeChoice"
                             , "choices" .= list (bs ++ [appPrim "non-exhaustive match" [] (tpe "Bottom")])
                             ]

        _ -> do bs <- mapM (genBranch scrutinees) branches
                let ds = map (\(cds,stmts)-> conjunction cds stmts) bs
                return $ obj [ "op" .= str "AlternativeChoice"
                             , "choices" .= list ds
                             ]
  where
    -- | Generates a statement for a branch with given return context
    genBranch :: [Doc] -> Branch -> Asm ([ConditionDoc], Doc)
    -- Regular catch-all branch generation
    genBranch tnDocs branch@(Branch patterns guards)
      = do modName <- getModule
           (conditions, substs) <- bimap concat concat . unzip <$> mapM (genTest modName) (zip tnDocs patterns)
           let se         = withNameSubstitutions substs

           gs <- mapM (se . genGuard) guards
           return (conditions, debugWrap ("genBranch: " ++ show substs) $ vcat gs)

    genGuard  :: Guard -> Asm Doc
    genGuard (Guard t expr)
      = do testE <- genExpr t
           exprSt <- genExpr expr
           return $ if isExprTrue t
                      then exprSt
                      else ifEqInt testE (text "1") exprSt
                      
    -- | Generates a list of boolish expression for matching the pattern
    genTest :: Name -> (Doc, Pattern) -> Asm ([ConditionDoc], [(TName, Doc)])
    genTest modName (scrutinee,pattern)
      = case pattern of
              PatWild -> return $ ([], [])
              PatVar tn pat
                -> do (conds, substs) <- genTest modName (scrutinee,pat)
                      return (conds, (tn, scrutinee):substs)
              PatLit (LitInt i)
                -> return ([ifEqInt scrutinee (text (show i))], [])
              PatLit lit@(LitString _)
                -> let tmp = var (str "tmp") (tpe "Int") in
                   return ([(\thn -> obj [ "op" .= str "Primitive"
                                    , "name" .= str "infixEq(String, String): Boolean"
                                    , "args" .= list [scrutinee, ppLit lit]
                                    , "returns" .= list [tmp]
                                    , "rest" .= ifEqInt tmp (text "1") thn
                                    ])
                   ], [])
              PatCon tn fields repr _ _ _ info skip  --TODO: skip test ?
                | getName tn == nameTrue
                -> return ([ifEqInt scrutinee (text "1")], [])
                | getName tn == nameFalse
                -> return ([ifEqInt scrutinee (text "0")], [])
                | otherwise
                -> case repr of
                     -- special
                     ConEnum _ _ _ tag
                       -> return ([ifEqInt scrutinee (int tag)], [])
--                      ConSingleton{}
--                        | getName tn == nameOptionalNone
--                        -> [ifNull scrutinee]
--                      ConSingleton _ DataStructAsMaybe _ _
--                        -> [ifNull scrutinee] -- <+> ppName (getName tn)]
--                      ConSingleton _ DataAsMaybe _ _
--                        -> [ifNull scrutinee] -- <+> ppName (getName tn)]
--                      ConSingleton _ DataAsList _ _
--                        -> [ifNull scrutinee] -- <+> ppName (getName tn)]
                     _ -> do fieldNames  <- (mapM (\(n,t) -> do x <- genVarName (asString $ ppName n)
                                                                return $ var x (transformType t)) (conInfoParams info))
                             let conTest = ifCon scrutinee (getConTypeTag info) (str $ show $ conInfoName info) fieldNames
                             (fieldTests, subfieldSubsts)  <- (bimap concat concat) . unzip <$> mapM
                                             (\(field,fieldName) -> genTest modName (debugWrap ("genTest: normal: " ++ show field ++ " -> " ++ show fieldName) fieldName, field) )
                                             ( zip fields fieldNames )
                             -- let fieldSubsts = zipWith (\(n,t) x -> (TName n t, x)) 
                             --                    (conInfoParams info) fieldNames
                             return ((conTest:fieldTests), subfieldSubsts) -- ++ fieldSubsts)

    ifEqInt :: Doc -> Doc -> ConditionDoc
    ifEqInt scrutinee lit thn = obj [ "op" .= str "Switch"
                                        , "scrutinee" .= scrutinee
                                        , "cases" .= list [obj ["value" .= lit, "then" .= thn ]]
                                        , "default" .= obj ["op" .= str "AlternativeFail"]
                                        ]

    ifNull :: Doc -> ConditionDoc
    ifNull scrutinee thn = let tmp = var (str "tmp") (tpe "Int") in 
                               obj [ "op" .= str "Primitive" 
                                   , "name" .= str "ptr_eq"
                                   , "args" .= list [scrutinee, var (text "-1") (tpe "Ptr")]
                                   , "returns" .= list [tmp]
                                   , "rest" .= ifEqInt tmp (text "1") thn
                                   ]

    ifCon :: Doc -> Doc -> Doc -> [Doc] -> ConditionDoc
    ifCon scrutinee tpt t fields thn = debugWrap ("ifCon@" ++ asString scrutinee ++ ": " ++ asString tpt ++ "." ++ asString t ++ "(" ++ asString (tupled fields) ++ ")")
                                         $ obj [ "op" .= str "Match"
                                               , "scrutinee" .= scrutinee
                                               , "type_tag" .= tpt
                                               , "clauses" .= list [obj ["tag" .= t, "params" .= list fields, "body" .= thn]]
                                               , "default_clause" .= obj ["params" .= list [], "body" .= obj ["op" .= str "AlternativeFail"]]
                                               ]

    -- | Takes a list of docs and concatenates them with logical and
    conjunction :: [ConditionDoc] -> ConditionDoc
    conjunction [] = id
    conjunction (doc:docs) = doc . (conjunction docs)

---------------------------------------------------------------------------------
-- Expressions that produce statements on their way
---------------------------------------------------------------------------------

-- | Generates javascript statements and a javascript expression from core expression
genExpr :: Expr -> Asm Doc
genExpr expr
  = -- trace ("genExpr: " ++ show expr) $
    case expr of
     -- check whether the expression is pure an can be inlined
     _  | isInlineableExpr expr -> genInline expr

     TypeApp e _ -> genExpr e
     TypeLam _ e -> genExpr e

     -- handle not inlineable cases
     App (TypeApp (Con name repr) _) [arg]  | getName name == nameOptional || isConIso repr
       -> genExpr arg
     App (Con _ repr) [arg]  | isConIso repr
       -> genExpr arg
     App (Var tname _) [Lit (LitInt i)]
       -> return $ obj [ "op" .= str "Literal", "type" .= str "Int", "value" .= pretty i ]

     -- special: .cctx-field-addr-of: create a tuple with the object and the field name as a string
     App (TypeApp (Var cfieldOf _) [_]) [Var con _, Lit (LitString conName), Lit (LitString fieldName)]  | getName cfieldOf == nameFieldAddrOf
       -> do conDoc <- genTName con
             return $ notImplemented (text "{obj:" <+> conDoc <.> text ", field_name: \"" <.> ppName (unqualify (readQualified fieldName)) <.> text "\"}")

     App f args
       -> case extractList expr of
                  Just (xs,tl) -> genList xs tl
                  Nothing -> case extractExtern f of
                   Just (tname,formats)
                     -> case args of
                         [Lit (LitInt i)] | getName tname == nameByte  && i >= 0 && i < 256
                           -> return (pretty i)
                         [Lit (LitInt i)] | getName tname `elem` [nameInt32,nameSSizeT,nameInternalInt32,nameInternalSSizeT]  && isSmallInt i
                           -> return (pretty i)
                         [Lit (LitInt i)] | getName tname `elem` [nameInt64,nameIntPtrT]  && isSmallInt i
                           -> return (pretty i <.> text "n")
                         _ -> -- genInlineExternal tname formats argDocs
                              do (argDocs) <- genExprs args
                                 (doc) <- genExprExternal tname formats argDocs
                                 if (getName tname == nameReturn)
                                  then return (text "")
                                  else return (doc)
                   Nothing
                    -> do lsDecls <- genExprs (f:trimOptionalArgs args)
                          let (fdoc:docs) = lsDecls
                          return $ obj [ "op" .= str "App"
                                       , "fn" .= fdoc
                                       , "args" .= list docs
                                       ]

     Let groups body
       -> do decls1       <- genGroups False groups
             (doc) <- genExpr body
             return $ obj [ "op" .= str "Let"
                          , "definitions" .= list decls1
                          , "body".= doc
                          ]

     Case _ _
       -> -- trace "Case" $ 
          do (doc, tname) <- genVarBinding expr
             nameDoc <- genTName tname
             return $ notImplemented $ text "Case" -- (doc, nameDoc)

     _ -> failure ("JavaScript.FromCore.genExpr: invalid expression:\n" ++ show expr)

extractList :: Expr -> Maybe ([Expr],Expr)
extractList e
  = let (elems,tl) = extract [] e
    in if (length elems > 10) -- only use inlined array for larger lists
        then Just (elems,tl)
        else Nothing
  where
    extract acc expr
      = case expr of
          App (TypeApp (Con name info) _) [hd,tl]  | getName name == nameCons
            -> extract (hd:acc) tl
          _ -> (reverse acc, expr)

genList :: [Expr] -> Expr -> Asm Doc
genList elems tl
  = do (docs) <- genExprs elems
       (tdoc) <- genExpr tl
       return (text "$std_core_vector.vlist" <.> tupled [list docs, tdoc])

genExprs :: [Expr] -> Asm [Doc]
genExprs exprs = mapM genExpr exprs

-- | Introduces an additional let binding in core if necessary
--   The expression in the result is guaranteed to be a Var afterwards
genVarBinding :: Expr -> Asm ([Doc], TName)
genVarBinding expr
  = case expr of
      Var tn _ -> return $ ([], tn)
      _        -> do name <- newVarName "x"
                     let tp = typeOf expr
                     val <- genExprStat expr
                     let defs  = [def (var (str $ show name) (transformType tp)) val]
                     return ( defs, TName name (typeOf expr) )

---------------------------------------------------------------------------------
-- Pure expressions
---------------------------------------------------------------------------------

genPure   :: Expr -> Asm Doc
genPure expr
  = case expr of
     TypeApp e _ -> genPure e
     TypeLam _ e -> genPure e
     Var name (InfoExternal formats)
       -> genWrapExternal name formats  -- unapplied inlined external: wrap as function
     Var name info
       -> asVar name -- genTName name
     Con name repr | getName name == nameUnit
       -> return $ obj [ "op" .= str "Literal", "type" .= transformType (tnameType name) ]
     Con name repr | getName name == nameTrue
       -> return $ obj [ "op" .= str "Literal", "value" .= text "1", "type" .= transformType (tnameType name) ]
     Con name repr | getName name == nameFalse
       -> return $ obj [ "op" .= str "Literal", "value" .= text "0", "type" .= transformType (tnameType name) ]
     Con name repr
       -> asVar name
     Lit l
       -> return $ ppLit l
     Lam params eff body
       -> do args <- mapM asVar params
             bodyDoc <- genExprStat body
             return $ obj [ "op" .= str "Abs"
                          , "params" .= list args
                          , "body" .= bodyDoc
                          ]
     _ -> failure ("JavaScript.FromCore.genPure: invalid expression:\n" ++ show expr)

isPat :: Bool -> Pattern -> Bool
isPat b q
  = case q of
      PatWild     -> False
      PatLit _    -> False
      PatVar _ q' -> isPat b q'
      PatCon {}   -> getName (patConName q) == if b then nameTrue else nameFalse

-- | Generates an effect-free javasript expression
--   NOTE: Throws an error if expression is not guaranteed to be effectfree
genInline :: Expr -> Asm Doc
genInline expr
  = -- trace "genInline" $ 
    case expr of
      _  | isPureExpr expr -> genPure expr
      TypeLam _ e -> genInline e
      TypeApp e _ -> genInline e
      App (TypeApp (Con name repr) _) [arg]  | getName name == nameOptional || isConIso repr
        -> genInline arg
      App (Con _ repr) [arg]  | isConIso repr
        -> genInline arg
      App f args
        -> do argDocs <- mapM genInline (trimOptionalArgs args)
              case extractExtern f of
                Just (tname,formats)
                  -> case args of
                       [Lit (LitInt i)] | getName tname `elem` [nameInt32,nameSSizeT,nameInternalInt32,nameInternalSSizeT, nameInt64,nameIntPtrT] && isSmallInt i
                         -> return (pretty i)
                       _ -> genInlineExternal tname formats argDocs
                Nothing
                  -> case (f,args) of
                       ((Var tname _),[Lit (LitInt i)]) | getName tname `elem` [nameInt32,nameSSizeT,nameInternalInt32,nameInternalSSizeT,nameInt64,nameIntPtrT] && isSmallInt i
                         -> return (pretty i)
                       _ -> do fdoc <- genInline f
                               return $ notImplemented $ (fdoc <.> tupled argDocs)

      _ -> failure ("VM.FromCore.genInline: invalid expression:\n" ++ show expr)

extractExtern :: Expr -> Maybe (TName,[(Target,String)])
extractExtern expr
  = case expr of
      TypeApp (Var tname (InfoExternal formats)) targs -> Just (tname,formats)
      Var tname (InfoExternal formats) -> Just (tname,formats)
      _ -> Nothing

-- not fully applied external gets wrapped in a function
genWrapExternal :: TName -> [(Target,String)] -> Asm Doc
genWrapExternal tname formats
  = do let n = snd (getTypeArities (typeOf tname))
       vs  <- genVarNames n
       doc <- genExprExternal tname formats vs
       return $ obj [ "op" .= str "Abs"
                    , "params" .= list vs
                    , "body" .= doc
                    ]
       -- $ notImplemented $ parens (text "function" ) -- <.> tupled vs <+> block (vcat ([text "return" <+> doc <.> semi])))

-- inlined external sometimes  needs wrapping in a applied function block
genInlineExternal :: TName -> [(Target,String)] -> [Doc] -> Asm Doc
genInlineExternal tname formats argDocs = genExprExternal tname formats argDocs

-- generate external: needs to add try blocks for primitives that can throw exceptions
genExprExternal :: TName -> [(Target,String)] -> [Doc] -> Asm (Doc)
genExprExternal tname formats argDocs0
  = do (doc) <- genExprExternalPrim tname formats argDocs0
       case splitFunType (typeOf tname) of
         Nothing -> return (doc)
         Just (pars,eff,res)
           -> let (ls,tl) = extractOrderedEffect eff
              in case filter (\l -> labelName l == nameTpPartial) ls of
                   [] -> return (doc)
                   _  -> -- has an exception type, wrap it in a try handler
                         let try = parens $
                                   parens (text "function()") --  <+> block (vcat (
                                    -- [text "try" <+> block (vcat ([text "return" <+> doc <.> semi]))
                                    -- ,text "catch(_err){ return $std_core._throw_exception(_err); }"]
                                    -- )))
                                   <.> text "()"
                         in return $ notImplemented (try)

-- special case: .cctx-hole-create
genExprExternalPrim :: TName -> [(Target,String)] -> [Doc] -> Asm (Doc)
genExprExternalPrim tname formats [] | getName tname == nameCCtxHoleCreate
  = return (text "undefined")

{-
-- special case: cfield-set (field is implemented as {value:<obj>, field:<string>})
genExprExternalPrim tname formats [accDoc,resDoc] | getName tname == nameCFieldSet
  = return ([], tupled [accDoc <.> text ".value[" <.> accDoc <.> text ".field] =" <+> resDoc, text "$std_core_types._Unit_"])
-}

-- normal external
genExprExternalPrim tname formats argDocs0
  = let name = getName tname
        format = getFormat tname formats
    in return $ (case (tnameType tname) of 
      TFun _ _ t -> appPrim format argDocs0 (transformType t)
      _ -> notImplemented $ text "Primitive non-function")

getFormat :: TName -> [(Target,String)] -> String
getFormat tname formats
  = case lookupTarget VM formats of  -- TODO: pass specific target from the flags
      Nothing -> -- failure ("backend does not support external in " ++ show tname ++ ": " ++ show formats)
                 trace( "warning: backend does not support external in " ++ show tname ) $
                    ("undefined external: " ++ (show tname))
      Just s -> s

genDefName :: TName -> Asm Doc
genDefName tname
  = return (ppName (unqualify (getName tname)))

genTName :: TName -> Asm Doc
genTName tname
  = do env <- getEnv
       case lookup tname (substEnv env) of
          Nothing -> genName (getName tname) (tnameType tname)
          Just d  -> return d

genName :: Name -> Type -> Asm Doc
genName name tpe
  = if (isQualified name)
      then do modname <- getModule
              if (qualifier name == modname)
               then return (ppName (unqualify name))
               else return $ obj [ "op" .= str "Qualified", "lib" .= libName (nameModule name), "name" .= (ppName name), "type" .= transformType tpe ]
      else return (ppName name)

genVarName :: String -> Asm Doc
genVarName s = do n <- newVarName s
                  return $ ppName n

-- | Generates `i` fresh variables and delivers them as `Doc` right away
genVarNames :: Int -> Asm [Doc]
genVarNames i = do ns <- newVarNames i
                   return $ map ppName ns

-- | Generate a name with its type in comments
genCommentTName :: TName -> Asm Doc
genCommentTName (TName n t)
  = do env <- getPrettyEnv
       return $ ppName n -- <+> comment (Pretty.ppType env t )

trimOptionalArgs args
  = reverse (dropWhile isOptionalNone (reverse args))
  where
    isOptionalNone arg
      = case arg of
          TypeApp (Con tname _) _ -> getName tname == nameOptionalNone
          _ -> False

---------------------------------------------------------------------------------
-- Classification
---------------------------------------------------------------------------------

extractExternal  :: Expr -> Maybe (TName, String, [Expr])
extractExternal expr
  = case expr of
      App (TypeApp (Var tname (InfoExternal formats)) targs) args
        -> Just (tname, format tname formats, args)
      App var@(Var tname (InfoExternal formats)) args
        -> Just (tname, format tname formats, args)
      _ -> Nothing
  where
    format tn fs
      = case lookupTarget (JS JsDefault) fs of  -- TODO: pass real target from flags
          Nothing -> failure ("backend does not support external in " ++ show tn ++ show fs)
          Just s -> s

isFunExpr :: Expr -> Bool
isFunExpr expr
  = case expr of
      TypeApp e _   -> isFunExpr e
      TypeLam _ e   -> isFunExpr e
      Lam args eff body -> True
      _                 -> False

isInlineableExpr :: Expr -> Bool
isInlineableExpr expr
  = case expr of
      TypeApp expr _   -> isInlineableExpr expr
      TypeLam _ expr   -> isInlineableExpr expr
      App (Var _ (InfoExternal _)) args -> all isPureExpr args
      {-
      -- TODO: comment out for now as it may prevent a tailcall if inlined
      App f args       -> -- trace ("isInlineable f: " ++ show f) $
                          isPureExpr f && all isPureExpr args
                          -- all isInlineableExpr (f:args)
                          && not (isFunExpr f) -- avoid `fun() {}(a,b,c)` !
                          -- && getParamArityExpr f == length args
      -}
      _                -> isPureExpr expr

isPureExpr :: Expr -> Bool
isPureExpr expr
  = case expr of
      TypeApp expr _  -> isPureExpr expr
      TypeLam _ expr  -> isPureExpr expr
      Var n (InfoConField{}) -> False
      Var n _  | getName n == nameReturn -> False -- make sure return will never be inlined
               | otherwise               -> True
      Con _ _ -> True
      Lit _   -> True
      Lam _ _ _ -> True
      _       -> False


isTailCalling :: Expr -> Name -> Bool
isTailCalling expr n
  = case expr of
      TypeApp expr _    -> expr `isTailCalling` n     -- trivial
      TypeLam _ expr    -> expr `isTailCalling` n     -- trivial
      Lam _ _ _           -> False                      -- lambda body is a new context, can't tailcall
      Var _ _           -> False                      -- a variable is not a call
      Con _ _           -> False                      -- a constructor is not a call
      Lit _             -> False                      -- a literal is not a call
      App (Var tn info) args   | getName tn == n            -- direct application can be a tail call
                        -> infoArity info == length args
      App (TypeApp (Var tn info) _) args | getName tn == n  -- tailcalled function might be polymorphic and is applied to types before
                        -> infoArity info == length args
      App (Var tn _) [e] | getName tn == nameReturn   -- a return statement is transparent in terms of tail calling
                        -> e `isTailCalling` n
      App _ _           -> False                      -- other applications don't apply
      Let _ e           -> e `isTailCalling` n        -- tail calls can only happen in the actual body
      Case _ bs         -> any f1 bs                  -- match statement get analyzed in depth
  where
    f1 (Branch _ gs) = any f2 gs                      -- does any of the guards tailcall?
    f2 (Guard _ e)   = e `isTailCalling` n            -- does the guarded expression tailcall?

---------------------------------------------------------------------------------
-- The assembly monad
---------------------------------------------------------------------------------

newtype Asm a = Asm { unAsm :: Env -> St -> (a, St)}

instance Functor Asm where
  fmap f (Asm a) = Asm (\env st -> case a env st of
                                     (x,st') -> (f x, st'))

instance Applicative Asm where
  pure x = Asm (\env st -> (x,st))
  (<*>)  = ap

instance Monad Asm where
  -- return = pure
  (Asm a) >>= f = Asm (\env st -> case a env st of
                                    (x,st1) -> case f x of
                                                 Asm b -> b env st1)
instance F.MonadFail Asm where
  fail = failure

runAsm :: Env -> Asm Doc -> Doc
runAsm initEnv (Asm asm)
  = case asm initEnv initSt of
      (doc,st) -> doc

data St  = St  { uniq     :: Int
               }

data Env = Env { moduleName        :: Name                    -- | current module
               , prettyEnv         :: Pretty.Env              -- | for printing nice types
               , substEnv          :: [(TName, Doc)]          -- | substituting names
               }

initSt = St 0

instance HasUnique Asm where
  updateUnique f
    = Asm (\env st -> (uniq st, st{ uniq = f (uniq st)}))

updateSt f
  = Asm (\env st -> (st,f st))

getSt
  = updateSt id

setSt st
  = updateSt (const st)

getEnv
  = Asm (\env st -> (env, st))

withEnv f (Asm asm)
  = Asm (\env st -> asm (f env) st)

localUnique asm
  = do u <- updateUnique id
       x <- asm
       setUnique u
       return x

newVarName :: String -> Asm Name
newVarName s
  = do u <- unique
       return (newName ("@" ++ s ++ show u))

newVarNames :: Int -> Asm [Name]
newVarNames 0 = return []
newVarNames i
  = do n  <- newVarName "x"
       ns <- newVarNames (i - 1)
       return (n:ns)

getModule :: Asm Name
getModule
  = do env <- getEnv
       return (moduleName env)

getPrettyEnv :: Asm Pretty.Env
getPrettyEnv
  = do env <- getEnv
       return (prettyEnv env)

withNameSubstitutions :: [(TName, Doc)] -> Asm a -> Asm a
withNameSubstitutions subs asm
  = withEnv (\env -> env{ substEnv = subs ++ substEnv env }) asm

---------------------------------------------------------------------------------
-- Pretty printing
---------------------------------------------------------------------------------
ppLit :: Lit -> Doc
ppLit lit
    = case lit of
      LitInt i    -> obj [ "op" .= str "Literal", "type" .= tpe "Int", "value" .= pretty i ]
      LitChar c   -> notImplemented $ text ("0x" ++ showHex 4 (fromEnum c))
      LitFloat d  -> notImplemented $ text (showsPrec 20 d "")
      LitString s -> obj [ "op" .= str "Literal", "type" .= tpe "String", "value" .= dquotes (hcat (map escape s)) ]
    where
      escape c
        = if (c < ' ')
           then (if (c=='\n') then text "\\n"
                 else if (c == '\r') then text "\\r"
                 else if (c == '\t') then text "\\t"
                 else text "\\u" <.> text (showHex 4 (fromEnum c)))
          else if (c <= '~')
           then (if (c == '\"') then text "\\\""
                 else if (c=='\'') then text "\\'"
                 else if (c=='\\') then text "\\\\"
                 else char c)
          else if (fromEnum c <= 0xFFFF)
           then text "\\u" <.> text (showHex 4 (fromEnum c))
          else if (fromEnum c > 0x10FFFF)
           then text "\\uFFFD"  -- error instead?
           else let code = fromEnum c - 0x10000
                    hi = (code `div` 0x0400) + 0xD800
                    lo = (code `mod` 0x0400) + 0xDC00
                in text ("\\u" ++ showHex 4 hi ++ "\\u" ++ showHex 4 lo)

isSmallInt i = (i > minSmallInt && i < maxSmallInt)

maxSmallInt, minSmallInt :: Integer
maxSmallInt = 9007199254740991  -- 2^53 - 1
minSmallInt = -maxSmallInt

ppName :: Name -> Doc
ppName name
  = quoted $ if isQualified name
     then ppModName (qualifier name) <.> dot <.> encode False (unqualify name)
     else encode False name

ppModName :: Name -> Doc
ppModName name
  = text "$" <.> encode True (name)

encode :: Bool -> Name -> Doc
encode isModule name
  = text $ asciiEncode isModule $ show name

debugWrap     :: String -> Doc -> Doc
debugWrap s d
  = if debug then obj [
    "op" .= str "DebugWrap",
    "inner" .= d,
    "annotation" .= str s
  ] else d

quoted :: Doc -> Doc
quoted d = text $ show $ asString d

str :: String -> Doc
str s = text $ show $ s

obj :: [Doc] -> Doc
obj = encloseSep lbrace rbrace comma

(.=) :: String -> Doc -> Doc
(.=) k v = text (show k ++ ":") <+> v

--------------------------------------------------------------------------------
-- Smart-constructors for instructions
--------------------------------------------------------------------------------
app :: Doc -> [Doc] -> Doc
app fn args = obj [ "op" .= text "\"App\""
                  , "fn" .= fn
                  , "args" .= list args
                  ]

primitive :: [Doc] -> String -> [Doc] -> Doc -> Doc
primitive outs name ins body = obj
  [ "op" .= str "Primitive"
  , "name" .= str name
  , "args" .= list ins
  , "returns" .= list outs
  , "rest" .= body
  ]

-- | Simplified primitive smart-constructor (works almost like function application)
appPrim :: String -- ^ name
        -> [Doc]  -- ^ args
        -> Doc    -- ^ return type
        -> Doc
appPrim name args tp = primitive [var (str "primitive_result") tp] name args (var (str "primitive_result") tp)

-- | Pseudo-instruction for not-yet supported parts
notImplemented :: Doc -> Doc
notImplemented doc = appPrim ("Not implemented: " ++ show (asString doc)) [] (tpe "Unit")

-- TODO other instructions

var :: Doc -> Doc -> Doc
var x t = obj [ "op" .= str "Var", "id" .= x, "type" .= t ]
asVar :: TName -> Asm Doc
asVar n = do env <- getEnv
             case lookup n (substEnv env) of
                Nothing -> return $ var (str $ show $ getName n) (transformType $ tnameType n)
                Just s -> return s

---- Types
tFn :: String -> [Doc] -> Doc -> Doc
tFn pur ps r = obj [ "op" .= text (show "Function")
                   , "params" .= list ps
                   , "return" .= r
                   , "purity" .= text (show pur)
                   ]

-- | Simple named type
tpe :: String -> Doc
tpe name = obj [ "op" .= text (show name) ]

---- Other forms

-- | Definitions
def :: Doc -> Doc -> Doc
def n v = obj [ "name" .= n, "value" .= v ]