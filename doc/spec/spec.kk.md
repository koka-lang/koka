# Koka language specification

This is the draft language specification of the Koka language, version 0.7.\
Currently only the lexical and context-free grammar are specified. 
The [standard libraries][stdlib] are documented separately.

[stdlib]: toc.html

## Lexical syntax 

We define the grammar and lexical syntax of the language using standard BNF
notation where non-terminals are generated by alternative patterns:

|~~~~~~~~~~~|~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~|
| _nonterm_ | ::= | _pattern_~1~ []{.bar} _pattern_~2~ |   |
{.grammar}

In the patterns, we use the following notations:

|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| `terminal`                         |   | A terminal symbol                                                          |
| ``x0A``                            |   | A character with hexadecimal code 0A                                       |
| ``a..f``                           |   | The characters from a to f                                                 |
| &nbsp;                             |   |                                                                            |
| ( _pattern_ )                      |   | Grouping                                                                   |
| [ _pattern_ ]                      |   | Optional occurrence of _pattern_                                           |
| { _pattern_ }                      |   | Zero or more occurrences of _pattern_                                      |
| _pattern_~1~ []{.bar} _pattern_~2~ |   | Choice: either _pattern_~1~ or _pattern_~2~                                |
| &nbsp;                             |   |                                                                            |
| _pattern_~&lt;!_diff_>~            |   | Difference: elements generated by _pattern_ except those in _diff_         |
| _pattern_~&lt;_postfix_>~          |   | Postfix: any elements in _pattern_ that are directly followed by _postfix_ |
| ~&lt;_prefix_>~_pattern_           |   | Prefix: any elements in _pattern_ that directly follow _prefix_            |
| _nonterm_~[\/_lex_]~               |   | Generate _nonterm_ by drawing lexemes from _lex_                           |
{.grammar}

Care must be taken to distinguish meta-syntax such as 
 []{.bar} and )
from concrete terminal symbols as ``|`` and ``)``. In the specification
the order of the productions is not important and at each point the
_longest matching lexeme_ is preferred. For example, even though
`function` is a reserved word, the word `functions` is considered a
single identifier. A _prefix_ or _postfix_ pattern is included 
when considering a longest match.
{.grammar}

### Source code

Source code consists of a sequence of 8-bit characters. Valid characters in
actual program code consists strictly of ASCII characters which range from 0
to 127 and can be encoded in 7-bits. Only comments, string literals, and
character literals are allowed to contain extended 8-bit characters.

### Encoding

A program source is assumed to be UTF-8 encoded which allows comments,
string literals, and character literals to contain (encoded) unicode
characters. Moreover, the grammar is designed such that a lexical
analyzer and parser can directly work on source files without doing UTF-8
decoding or unicode category identification. To further facilitate the
processing of UTF-8 encoded files the lexical analyzer ignores an initial
byte-order mark that some UTF-8 encoders insert. In particular, any
program source is allowed to start with three byte-order mark bytes
``0xEF``, ``0xBB``, and ``0xBF``, which are ignored.

## Lexical grammar

In the specification of the lexical grammar all white space is explicit
and there is no implicit white space between juxtaposed symbols. The
lexical token stream is generated by the non-terminal _lex_ which
consists of lexemes and whitespace.

Before doing lexical analysis, there is a _linefeed_ character inserted
at the start and end of the input, which makes it easier to specify line
comments and directives.

### Lexical tokens { test }

| ~~~~~~~~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~|
| _lex_                | ::=   | _lexeme_ []{.bar} _whitespace_                               |     |
| _lexeme_&nbsp;&nbsp; | ::=   | _conid_ []{.bar} _qconid_                                    |     |
|                      | &bar; | _varid_ []{.bar} _qvarid_                                    |     |
|                      | &bar; | _op_ []{.bar} _opid_ []{.bar} _qopid_ []{.bar} _wildcard_    |     |
|                      | &bar; | _natural_ []{.bar} _float_ []{.bar} _string_ []{.bar} _char_ |     |
|                      | &bar; | _reserved_ []{.bar} _opreserved_                             |     |
|                      | &bar; | _special_ []{.bar} _funanon_                                 |     |
{.grammar .lex}

The main program consists of _whitespace_ or _lexeme_'s. The context-free
grammar will draw it's lexemes from the _lex_ production.

### Identifiers

|~~~~~~~~~~~~~~|~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _anyid_      | ::=   | _varid_ []{.bar} _qvarid_ []{.bar} _opid_ []{.bar} _qopid_ []{.bar} _conid_ []{.bar} _qconid_ |                                                         |
| &nbsp;       |       |                                                                                               |                                                         |
| _qconid_     | ::=   | _modulepath_ _conid_                                                                          |                                                         |
| _qvarid_     | ::=   | _modulepath_ _lowerid_                                                                        |                                                         |
| _modulepath_ | ::=   | _lowerid_ `/` [_lowerid_ `/`]{.many}                                                          |                                                         |
| &nbsp;       |       |                                                                                               |                                                         |
| _conid_      | ::=   | _upperid_                                                                                     |                                                         |
| _varid_      | ::=   | _lowerid_~&lt;!_reserved_&gt;~                                                                |                                                         |
| &nbsp;       |       |                                                                                               |                                                         |
| _lowerid_    | ::=   | _lower_ _idtail_                                                                              |                                                         |
| _upperid_    | ::=   | _upper_ _idtail_                                                                              |                                                         |
| _wildcard_   | ::=   | ``_`` _idtail_                                                                                |                                                         |
| _typevarid_  | ::=   | _letter_ [_digit_]{.many}                                                                     |                                                         |
| &nbsp;       |       |                                                                                               |                                                         |
| _idtail_     | ::=   | [_idchar_]{.many} [_idfinal_]{.opt}                                                           |                                                         |
| _idchar_     | ::=   | _letter_ []{.bar} _digit_ []{.bar} ``_`` []{.bar} ``-``                                       |                                                         |
| _idfinal_    | ::=   | ``?`` []{.bar} [``'``]{.many}                                                                 |                                                         |
| &nbsp;       |       |                                                                                               |                                                         |
| _funanon_    | ::=   | (`fun` []{.bar} `function`)~&lt;\ ``<``[]{.bar}``(``&gt;~                                     | (anonymous functions must be followed by a `(` or `<`)) |
| _reserved_   | ::=   | `infix` []{.bar} `infixr` []{.bar} `infixl` []{.bar} `prefix`                                 |                                                         |
|              | &bar; | `type` []{.bar} `cotype` []{.bar} `rectype` []{.bar} `alias`                                  |                                                         |
|              | &bar; | `forall` []{.bar} `exists` []{.bar} `some`                                                    |                                                         |
|              | &bar; | `fun` []{.bar} `function` []{.bar} `val` []{.bar} `var` []{.bar} `con`                        |                                                         |
|              | &bar; | `if` []{.bar} `then` []{.bar} `else` []{.bar} `elif` []{.bar} `match` []{.bar} `return`       |                                                         |
|              | &bar; | `module` []{.bar} `import` []{.bar} `as`                                                      |                                                         |
|              | &bar; | `public` []{.bar} `private` []{.bar} `abstract`                                               |                                                         |
|              | &bar; | `interface` []{.bar} `instance` []{.bar} `with`                                               |                                                         |
|              | &bar; | `external` []{.bar} `inline` []{.bar} `include`                                               |                                                         |
|              | &bar; | `effect` []{.bar} `handle` []{.bar} `handler` []{.bar} `linear`                               |                                                         |
|              | &bar; | `yield` []{.bar} `qualified` []{.bar} `hiding`                                                | (future reserved words)                                 |
{.grammar .lex}

Identifiers always start with a letter, may contain underscores and
dashes, and can end with a question mark or primes. 
Like in Haskell, constructors always begin with an uppercase
letter while regular identifiers are lowercase. The rationale is to 
visibly distinguish constants from variables in pattern matches. 
Here are some example of valid identifiers:
```unchecked
x
concat1
visit-left
nil?
x'
Cons
True  
```
To avoid confusion with the subtraction operator, the occurrences of
dashes are restricted in identifiers. After lexical analysis, only
identifiers where each dash is surrounded on both sides with a _letter_
are accepted:

````koka
fold-right
n-1        // illegal, a digit cannot follow a dash
n - 1      // n minus 1
n-x-1      // illegal, a digit cannot follow a dash
n-x - 1    // identifier "n-x" minus 1
n - x - 1  // n minus x minus 1
````
Qualified identifiers are prefixed with a module path. Module
paths can be partial as long as they are unambiguous. 

````koka
core/map
std/core/(&)
````

### Operators and symbols

| ~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~|
| _qopid_      | ::=   | _modulepath_ _opid_                                                                                                                                   |    |
| _opid_       | ::=   | `(` _symbols_ `)`                                                                                                                                     |    |
| &nbsp;       |       |                                                                                                                                                       |    |
| _op_         | ::=   | _symbols_~&lt;!\ _opreserved_[]{.bar}_optype_&gt;~  []{.bar}  ``\(&bar;&bar;\)``                                                                      |    |
| &nbsp;       |       |                                                                                                                                                       |    |
| _symbols_    | ::=   | _symbol_ [_symbol_]{.many}[]{.bar} ``/``                                                                                                             |    |
| _symbol_     | ::=   | `$` []{.bar} `%` []{.bar} ``&`` []{.bar} `*` []{.bar} `+`                                                                                             |    |
|              | &bar; | ``~`` []{.bar} ``!`` []{.bar} ``\`` []{.bar} `^` []{.bar} ``#``                                                                                       |    |
|              | &bar; | ``=`` []{.bar} ``.`` []{.bar} ``:`` []{.bar} `-` []{.bar} `?`                                                                                         |    |
|              | &bar; | _anglebar_                                                                                                                                            |    |
| _anglebar_   | ::=   | ``<`` []{.bar} ``>`` []{.bar} ``\(&bar;\)``                                                                                                           |    |
| &nbsp;       |       |                                                                                                                                                       |    |
| _opreserved_ | ::=   | `=` []{.bar} `.` []{.bar} ``:`` []{.bar} `->`                                                                                                         |    |
| _optype_     | ::=   | _anglebar_ _anglebar_ [_anglebar_]{.many}                                                                                                             |    |
| &nbsp;       |       |                                                                                                                                                       |    |
| _special_    | ::=   | `{` []{.bar} `}` []{.bar} `(` []{.bar} `)` []{.bar} `[` []{.bar} `]` []{.bar} ``\(&bar;\)`` []{.bar} `;` []{.bar} `,` []{.bar} &lapp; []{.bar} &lidx; |    |
| &lapp;       | ::=   | ~&lt;_apply_&gt;~`(`                                                                                                                                  |    |
| &lidx;       | ::=   | ~&lt;_apply_&gt;~`[`                                                                                                                                  |    |
| _apply_      | ::=   | `)` []{.bar} `]` []{.bar} _anyid_                                                                                                                     |    |
| &nbsp;       |       |                                                                                                                                                       |    |
{.grammar .lex}

### Literals

|~~~~~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~|
| _string_      | ::=    | ``@"`` [_graphic_~&lt;``"``&gt;~ []{.bar} _utf8_ []{.bar} _space_ []{.bar} _tab_ []{.bar} _newline_ []{.bar} ``""``]{.many} ``"`` | (raw string) |
|               | &bar;  | ``"`` [_graphic_~&lt;``"``[]{.bar}``\``&gt;~ []{.bar} _utf8_ []{.bar} _space_ []{.bar} _escape_]{.many} ``"``                     |              |
| _char_        | ::=    | ``'`` ( _graphic_~&lt;``'``[]{.bar}``\``&gt;~ []{.bar} _utf8_ []{.bar} _space_ []{.bar} _escape_ ) ``'``                          |              |
| &nbsp;        |        |                                                                                                                           |              |
| _escape_      | ::=    | ``\`` ( _charesc_ []{.bar} _hexesc_ )                                                                                       |              |
| _charesc_     | ::=    | `n` []{.bar} `r` []{.bar} `t` []{.bar} ``\`` []{.bar} ``"`` []{.bar} ``'``                                                      |              |
| _hexesc_      | ::=    | `x` _hexdigit_~2~ []{.bar}   `u` _hexdigit_~4~ []{.bar}   ``U`` _hexdigit_~4~ _hexdigit_~2~                                 |              |
| _hexdigit_~4~ | ::=    | _hexdigit_ _hexdigit_ _hexdigit_ _hexdigit_                                                                               |              |
| _hexdigit_~2~ | ::=    | _hexdigit_ _hexdigit_                                                                                                     |              |
| &nbsp;        |        |                                                                                                                           |              |
| _float_       | ::=    | _decimal_ `.` _decimal_ [_exponent_]{.opt}                                                                                |              |
| _exponent_    | ::=    | (``e`` &bar;  ``E``) [``-`` &bar;  ``+``]{.opt} _decimal_                                                                     |              |
| _natural_     | ::=    | _decimal_ []{.bar} `0` &nbsp; (``x`` &bar;  ``X``) _hexadecimal_                                                              |              |
| _decimal_     | ::=    | _digit_ [_digit_]{.many}                                                                                                  |              |
| _hexadecimal_ | ::=    | _hexdigit_ [_hexdigit_]{.many}                                                                                            |              |
{.grammar .lex}

### White space

|~~~~~~~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _whitespace_    | ::=    | _white_ [_white_]{.many} []{.bar} _newline_                                                                           |                          |
| _white_         | ::=    | _space_                                                                         |                          |
|                 | &bar;  | _linecomment_ []{.bar} _blockcomment_                                                              |                          |
|                 | &bar;  | _linedirective_                                                                                    |                          |
| &nbsp;          |        |                                                                                                    |                          |
| _linecomment_   | ::=    | ``//`` [_linechar_]{.many}                                                                  |                          |
| _linedirective_ | ::=    | _newline_ ``#`` [_linechar_]{.many}                                            |                          |
| _linechar_      | ::=    | _graphic_ []{.bar} _utf8_ []{.bar} _space_ []{.bar} _tab_                                          |                          |
| &nbsp;          |        |                                                                                                    |                          |
| _blockcomment_  | ::=    | <code>/&#42;</code> _blockpart_ [_blockcomment_ _blockpart_]{.many} <code>&#42;/</code>            | (allows nested comments) |
| _blockpart_     | ::=    | _blockchars_~&lt;_blockchars_\ (<code>/&#42;</code>[]{.bar}<code>&#42;/</code>)\ _blockchars_&gt;~ |                          |
| _blockchars_    | ::=    | [_blockchar_]{.many}                                                                               |                          |
| _blockchar_     | ::=    | _graphic_ []{.bar} _utf8_ []{.bar} _space_ []{.bar} _tab_ []{.bar} _newline_                       |                          |
{.grammar .lex}

### Character classes

|~~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _letter_   | ::=    | _upper_ []{.bar} _lower_                |                                     |
| _upper_    | ::=    | ``A..Z``                                  |                                     |
| _lower_    | ::=    | ``a..z``                                  |                                     |
| _digit_    | ::=    | ``0..9``                                  |                                     |
| _hexdigit_ | ::=    | ``a..f`` []{.bar} ``A..F`` []{.bar} _digit_ |                                     |
| &nbsp;     |        |                                         |                                     |
| _newline_  | ::=    | [_return_]{.opt} _linefeed_             | (windows or unix style end of line) |
| &nbsp;     |        |                                         |                                     |
| _space_    | ::=    | ``x20``                                   | (a space)                           |
| _tab_      | ::=    | ``x09``                                   | (a tab (``\t``))                      |
| _linefeed_ | ::=    | ``x0A``                                   | (a line feed (``\n``))                |
| _return_   | ::=    | ``x0D``                                   | (a carriage return (``\r``))          |
| _graphic_  | ::=    | ``x21``..``x7E``                            | (a visible character)               |
| &nbsp;     |        |                                         |                                     |
| _utf8_     | ::=    | ``xC0`` ``x80``                             | (encoded 0 character)               |
|            | &bar;  | (``xC2``..``xDF``) _cont_                   |                                     |
|            | &bar;  | ``xE0`` (``xA0``..``xBF``) _cont_             |                                     |
|            | &bar;  | (``xE1``..``xEC``) _cont_ _cont_            |                                     |
|            | &bar;  | ``xED`` (``x80``..``x9F``) _cont_             |                                     |
|            | &bar;  | (``xEE``..``xEF``) _cont_ _cont_            |                                     |
|            | &bar;  | ``xF0`` (``x90``..``xBF``) _cont_ _cont_      |                                     |
|            | &bar;  | (``xF1``..``xF3``) _cont_ _cont_ _cont_     |                                     |
|            | &bar;  | ``xF4`` (``x80``..``x8F``) _cont_ _cont_      |                                     |
| _cont_     | ::=    | ``x80``..``xBF``                            |                                     |
{.grammar .lex}

### Semicolons?

Many languages have rules to avoid writing semicolons to separate
statements. Even though most of the time these rules are quite intuitive
to use, their actual definition can be quite subtle. For example,
both [Scala][lscala] and [Go][lgo] require remembering specific tokens to
know precisely when semicolon insertion takes place. In the case
of [JavaScript][ljavascript] and [Haskell][lhaskell] (I am sad to admit)
the precise behavior is bizarrely complex where semicolon insertion
depends on the interaction between the lexer and parser.

In Koka, the grammar is carefully constructed to not need any statement
separator at all and semicolons are never required by the grammar.
They are still allowed in the grammar but strictly to help new programmers
that are used to putting semicolons at the end of statements.

The construction of a grammar that does not need statement separators is
also good from a human perspective. The reason semicolons are required is
to resolve ambiguities in the syntax. When such ambiguities do not occur
in the first place, that also removes a cognitive burden from the
programmer. In particular, Koka statements often start with a keyword,
like `val` or `match`, signifying intention to both programmer and parser.

In other cases, we restrict the expression grammar. For example, one
reason why C requires semicolons is due to prefix- and postfix operators.
If we write ``p ++ q`` the C parser needs a semicolon in order to know if
we meant ``p++; q`` or ``p; ++q``. Such ambiguity is resolved in Koka by
not having postfix operators and restricting prefix operators to ``!``
and ``~``. 

One other reason that Koka can do without a statement separator is the
effect inference system: without such effect inference subtle bugs may
occur if we leave out semicolons. For example, consider the following
function:
```
fun square( x : int ) {
  x * x
}
```
which returns the square of `x`. Suppose now that we forgot to put
in the multiplication operation, giving:
```unchecked
fun square-wrong( x : int ) {
  x x
}
```
The Koka grammar sees this as 2 separate statements now, &ie; as ``x; x`` 
returning ``x`` instead. In a language without effect inference it is hard
to detect such errors, but the Koka type system rejects this program: 

    > fun square-wrong(x:int) { x x }
                                ^
    ((1),27): error: expression has no effect and is unused
      hint: did you forget an operator? or is there a space between an application?


[LHaskell]: http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3  
[LPython]: http://docs.python.org/2/reference/lexical_analysis.html
[LJavaScript]: https://tc39.github.io/ecma262/#sec-rules-of-automatic-semicolon-insertion
[LScala]: http://www.scala-lang.org/old/sites/default/files/linuxsoft_archives/docu/files/ScalaReference.pdf#page=13
[LGo]: http://golang.org/ref/spec#Semicolons


<!--
### Semicolon insertion  {#sec:layout}

Just like programming languages like 
[Haskell], [Python], [JavaScript], [Scala], [Go], etc., there is a layout rule
which automatically adds semicolons at appropriate places. This enables the
programmer to leave out most semicolons.


Koka will insert semicolons automatically for any statements
and declarations that are _aligned between curly braces_ (`{` and `}`).
For example, in the following program:
{.grammar}

```
function eq1( x : int, y : int ) : io bool 
{  
  print("calculate equality")
  val result = if (x == y) then True            
                else False
  result
}  
```

we get semicolons before each statement that was aligned between the braces:

```
function eqSemi( x : int, y : int ) : io bool 
{;  
  print("calculate equality");
  val result = if (x == y) then True            
                else False;
  result;
}  
```

Since semicolons are only inserted for _aligned_ statements, we can
write a long statement on multiple lines by using more indentation:

```
function eq2( x : int, y : int ) : io bool 
{  
  print("calculate " +
         "equ" +
         "ality")
  val result = if (x == y)
                then True 
                else False
  result
}  
```

In contrast to token-based layout rules, as in [Scala] or [Go] for example, this
allows you to put line breaks at any point in a statement by just indenting
more. Moreover, it means that the visual indentation of a program corresponds
directly to how the compiler interprets the statements. Many tricky layout
examples in other programming languages are often based on a mismatch between
the visual representation and how a compiler interprets the tokens. With
Koka's layout rule, there is no such mismatch.

To still allow for "block-style" layout, the
layout rule does not insert a  semicolon for an aligned statement if it
starts with `then`, `else`, `elif`, or one of `{`, `)`, or `]`.
{.grammar}

```
function bar()
{  
  val xs = [ 
    "list",
    "elements",
  ]
  if (odd?(random-int())) 
  {
    print("odd")
  }
  else 
    print("even")
}  
```

Of course, it is still allowed to use semicolons explicitly which can be used
for example to put multiple statements on a single line:

```
function equalLine( x : int, y : int ) : io bool {
  print("calculate equality"); (x == y) 
}  
```

The layout algorithm also checks for invalid layouts where the layout would
not visually correspond to how the compiler interprets the tokens. In
particular, it is illegal to indent less than the layout context or to put
comments into the indentation (because of tabs or potential unicode
characters). For example, the program:

```unchecked
function equal( x : int, y : int ) : io bool {   
    print("calculate equality")
  result = if (x == y) then True   // wrong: too little indentation
  /* wrong */      else False
    result
}  
```

is rejected. In order to facilitate code generation or source code
compression, compilers are also required to support a mode where the layout
rule is not applied and where no semicolons are inserted. A recognized command
line flag for that mode should be ``--nolayout``.

#### The layout algorithm

The layout rule is natural to humans since semicolon insertion corresponds
directly to the visual two-dimensional layout of the program. The formal
specification of the layout rule is a bit more technical though since a
compiler interprets source code as a linear one-dimensional sequence. To
define the layout algorithm formally, we first establish some terminology:

* A new line is started after every _linefeed_ character.
* Any non-_white_ token is called a _lexeme_, where a line without lexemes 
  is called _blank_.
* The indentation of a lexeme is the column number of its first character on 
  that line (starting at 1), and the indentation of a line is the indentation 
  of the first lexeme on the line.

Because braces can be nested, we use a _layout stack_ of strictly
increasing indentations. The top indentation on the layout stack holds the
_layout indentation_. The initial layout stack contains the single
value 0 (which is never popped). The operations on the layout stack are always
done before the semicolon insertion:

* _Layout stack operations_: If the previous lexeme was an
  open brace `{` or the start of the lexical token sequence, we push the
  indentation of the current lexeme on the layout stack. The pushed indentation
  must be larger than the previous layout indentation (unless the current lexeme
  is a closing brace).  When a closing brace `}` is encountered the top
  indentation is popped from the layout stack.

* _Semicolon insertion_: For each non-blank line, the
  indentation must be equal or larger to the layout indentation. A semicolon is
  inserted before the line whenever the indentation is equal, unless the first
  lexeme on the line is one of `then`, `else`, `elif`, or one of `{`, `)`, or
  `]`. Also, a semicolon is always inserted before a closing brace `}` and
  before the end of the token sequence.
{.grammar} 

As defined, semicolons are inserted whenever statements or declarations are
aligned, unless the lexeme happens to be a clear statement continuation. To
simplify the grammar specification, a semicolon is also always inserted before
a closing brace and the end of the source. This allows us to specify many
grammar elements as ended by semicolons instead of separated by semicolons
which is more difficult to specify for a LALR(1) grammar.

Semicolon insertion can be easily implemented as part of the lexer, but could
also be implemented as a straightforward transformation on the lexical token
stream. In particular, there are no intricate dependencies with the parser
that lead to bizarrely complex layout rules, as is the case in languages like
[Haskell] or [JavaScript].
-->

### Implementation { #sec:lex-implementation }

There is a full [Flex (Lex) implementation][FlexLexer] of lexical
analysis, Ultimately, the Flex implementation serves as _the_
specification, and this document and the Flex implementation should
always be in agreement.

## Context-free syntax

The grammar specification starts with the non terminal _module_ which draws
its lexical tokens from _lex_ where all _whitespace_ tokens are implicitly
ignored.

### Modules

|~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~|
| _module_~[_lex_]{.opt}~ | ::=    | [_moduledecl_]{.opt} _modulebody_                         |   |
| &nbsp;                  |        |                                                           |   |
| _moduledecl_            | ::=    | _semis_  [_visibility_]{.opt} `module` _moduleid_ |   |
| _moduleid_              | ::=    | _qvarid_ []{.bar} _varid_                                 |   |
| &nbsp;                  |        |                                                           |   |
| _modulebody_            | ::=    | `{` _semis_ _declarations_ `}` _semis_    |   |
|                         | &bar;  | _semis_ _declarations_                            |   |
| &nbsp;                  |        |                                                           |   |
| _visibility_            | ::=    | `public` []{.bar} `private`                               |   |
| _semis_                 | ::=    | [`;`]{.many}                                          |   |
{.grammar .parse}

### Top level declarations

|~~~~~~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~|
| _declarations_ | ::=    | [_import_ _semis_]{.many} [_fixitydecl_ _semis_]{.many} [_topdecl_ _semis_]{.many} |   |
| &nbsp;         |        |                                                                                    |   |
| _import_       | ::=    | [_visibility_]{.opt} `import` [_moduleid_ `=`]{.opt} _moduleid_                    |   |
| &nbsp;         |        |                                                                                    |   |
| _fixitydecl_   | ::=    | [_visibility_]{.opt} _fixity_ _natural_ _identifier_ [`,` _identifier_]{.many}     |   |
| _fixity_       | ::=    | `infixl`                                                                           |   |
|                | &bar;  | `infixr`                                                                           |   |
|                | &bar;  | `infix`                                                                            |   |
| &nbsp;         |        |                                                                                    |   |
| _topdecl_      | ::=    | [_visibility_]{.opt} _puredecl_                                                    |   |
|                | &bar;  | [_visibility_]{.opt} _aliasdecl_                                                   |   |
|                | &bar;  | [_visibility_]{.opt} _typedecl_                                                    |   |
|                | &bar;  | [_visibility_]{.opt} _externdecl_                                                  |   |
|                | &bar;  | `abstract ` _typedecl_                                                             |   |
{.grammar .parse}

### Type declarations

| ~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~|
| _aliasdecl_   | ::=   | `alias` _typeid_ [_typeparams_]{.opt} [_kannot_]{.opt} `=` _type_                              |    |
| _typedecl_    | ::=   | _typesort_ [_typemod_]{.opt} _typeid_ [_typeparams_]{.opt} [_kannot_]{.opt} [_typebody_]{.opt} |    |
|               | &bar; | `struct` _typeid_ [_typeparams_]{.opt} [_kannot_]{.opt} [_conparams_]{.opt}                    |    |
|               | &bar; | `effect` [`linear`]{.opt} _typeid_ [_typeparams_]{.opt} [_kannot_]{.opt} [_opdecls_]{.opt}     |    |
| _typesort_    | ::=   | `type` []{.bar} `cotype` []{.bar} `rectype`                                                    |    |
| _typemod_     | ::=   | `open` []{.bar} `extend`                                                                       |    |
| &nbsp;        |       |                                                                                                |    |
| _typeid_      | ::=   | _varid_                                                                                        |    |
|               | &bar; | ``[]``                                                                                         |    |
|               | &bar; | `(` [`,`]{.many} `)`                                                                           |    |
|               | &bar; | `<` `>`                                                                                        |    |
|               | &bar; | `<` [&bar; ]{.koka .code} `>`                                                                  |    |
| &nbsp;        |       |                                                                                                |    |
| _typeparams_  | ::=   | `<` [_tbinders_]{.opt} `>`                                                                     |    |
| _tbinders_    | ::=   | _tbinder_ [`,` _tbinder_]{.many}                                                               |    |
| _tbinder_     | ::=   | _varid_ [_kannot_]{.opt}                                                                       |    |
| _typebody_    | ::=   | `{` _semis_ [_constructor_ _semis_]{.many} `}`                                                 |    |
| &nbsp;        |       |                                                                                                |    |
| _constructor_ | ::=   | [`con`]{.opt} _conid_ [_typeparams_]{.opt} [_conparams_]{.opt}                                 |    |
| _conparams_   | ::=   | _lparen_ [_conparam_ [`,` _conparam_]{.many}]{.opt} `)`                                        |    |
| _conparam_    | ::=   | [_paramid_]{.opt} ``:`` _paramtype_ [`=` _expr_]{.opt}                                         |    |
| _lparen_      | ::=   | _lapp_ []{.bar} `(`                                                                            |    |
| &nbsp;        |       |                                                                                                |    |
| _opdecls_     | ::=   | `{` _semis_ [_opdecl_ _semis_]{.many} `}`                                                      |    |
| _opdecl_      | ::=   | [_visibility_]{.opt} _identifier_ [_typeparams_]{.opt} _opparams_ [ ``:`` _tatom_]{.opt}       |    |
| _opparams_    | ::=   | _lparen_ [_opparam_ [`,` _opparam_]{.many}]{.opt} `)`                                          |    |
| _opparam_     | ::=   | [_paramid_]{.opt} ``:`` _paramtype_                                                            |    |
{.grammar .parse}

### Value and function declarations

| ~~~~~~~~~~~~~~~~ | ~~~~~~~~ | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | ~~~~~~~~~~~~~~~~~~~~~ |
| _puredecl_       | ::=      | `val` _valdecl_                                                                               |                       |
|                  | &bar;    | (`fun`[]{.bar}`function`) _fundecl_                                                                          |                       |
| &nbsp;           |          |                                                                                               |                       |
| _valdecl_        | ::=      | _binder_ `=` _expr_                                                                           |                       |
| _binder_         | ::=      | _identifier_ [``:`` _type_]{.opt}                                                               |                       |
| &nbsp;           |          |                                                                                               |                       |
| _fundecl_        | ::=      | _somes_ _funid_ _fundef_ _bodyexpr_                     |                       |
| _fundef_         | ::=      | [_typeparams_]{.opt} _parameters_ [``:`` _tresult_]{.opt} [_qualifier_]{.opt}                                        |                       |
| _funid_          | ::=      | _identifier_                                                                                  |                       |
|                  | &bar;    | ``[`` [`,`]{.many} ``]``                                                                          | (indexing operator)   |
| &nbsp;           |          |                                                                                               |                       |
| _parameters_     | ::=      | _lparen_ [_parameter_ [`,` _parameter_]{.many}]{.opt} `)`                                     |                       |
| _parameter_      | ::=      | _paramid_ [``:`` _paramtype_]{.opt} [`=` _expr_]{.opt}                                          |                       |
| _paramid_        | ::=      | _identifier_ []{.bar} _wildcard_                                                              |                       |
| _paramtype_      | ::=      | _type_                                                                                        |                       |
|                  | &bar;    | `?` _type_                                                                                    | (optional parameter)                      |
| &nbsp;           |          |                                                                                               |                       |
| _qidentifier_    | ::=      | _qvarid_ []{.bar} _qidop_ []{.bar} _identifier_                                               |                       |
| _identifier_     | ::=      | _varid_ []{.bar} _idop_                                                                       |                       |
| &nbsp;           |          |                                                                                               |                       |
| _qoperator_      | ::=      | _op_                                                                                          |                       |
| &nbsp;           |          |                                                                                               |                       |
| _qconstructor_   | ::=      | _conid_ []{.bar} _qconid_                                                                     |                       |
{.grammar .parse}

### Statements

| ~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _block_     | ::=   | ``{`` _semis_ [_statement_ _semis_]{.many} ``}`` |                                          |
| &nbsp;      |       |                                                  |                                          |
| _statement_ | ::=   | _expr_~&lt;!\ _funexpr_&gt;~                     |                                          |
|             | &bar; | _decl_                                           |                                          |
| &nbsp;      |       |                                                  |                                          |
| _decl_      | ::=   | (`fun`[]{.bar}`function`) _fundecl_              |                                          |
|             | &bar; | `val` _apattern_ `=` _valexpr_                   | (local values can use a pattern binding) |
|             | &bar; | `var` _binder_ ``:=`` _valexpr_                  |                                          |
{.grammar .parse}

### Expressions


| ~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _bodyexpr_    | ::=   | `->` _blockexpr_                                                            |                                    |
|               | &bar; | _block_                                                                     |                                    |
| &nbsp;        |       |                                                                             |                                    |
| _blockexpr_   | ::=   | _expr_                                                                      | (implicitly wrapped in a block)    |
| &nbsp;        |       |                                                                             |                                    |
| _expr_        | ::=   | _returnexpr_                                                                |                                    |
|               | &bar; | _matchexpr_                                                                 |                                    |
|               | &bar; | _handlerexpr_                                                               |                                    |
|               | &bar; | _funexpr_                                                                   |                                    |
|               | &bar; | _ifexpr_                                                                    |                                    |
|               | &bar; | _opexpr_                                                                    |                                    |
| &nbsp;        |       |                                                                             |                                    |
| _ifexpr_      | ::=   | `if` _atom_ _then_ [_elif_]{.many} [`else` _expr_~&lt;!_ifexpr_&gt;~]{.opt} |                                    |
| _then_        | ::=   | [`then`]{.opt} _expr_~&lt;!_ifexpr_&gt;~                                    |                                    |
| _elif_        | ::=   | `elif` _atom_ _then_                                                        |                                    |
| &nbsp;        |       |                                                                             |                                    |
| _matchexpr_   | ::=   | `match` _atom_ `{` _semis_ [_matchrule_ _semis_]{.many} `}`                 |                                    |
| _returnexpr_  | ::=   | `return` _opexpr_                                                           |                                    |
| _funexpr_     | ::=   | _funanon_ _fundef_ _block_                                                  |                                    |
|               | &bar; | _block_                                                                     | (zero-argument anonymous function) |
| _handlerexpr_ | ::=   | `handler` _handlereff_ _handlerpars_ `{` _handlerrules_ `}`                 |                                    |
|               | &bar; | `handle` _handlereff_ _haction_ _handlerpars_ `{` _handlerrules_ `}`        |                                    |
| _haction_     | ::=   | lparen _expr_ `)`                                                            |                                    |
{.grammar .parse}

### Operator expressions

For simplicity, we parse all operators as if they are left associative with
the same precedence. We assume that a separate pass in the compiler will use
the fixity declarations that are in scope to properly associate all operators
in an expressions.

| ~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _opexpr_     | ::=   | _prefix_ [_qoperator_ _prefixexpr_]{.many} |                              |
| _prefixexpr_ | ::=   | [``!`` []{.bar} ``~``]{.many} _appexpr_    |                              |
| &nbsp;       |       |                                            |                              |
| _appexpr_    | ::=   | _appexpr_ _lapp_ [_arguments_]{.opt} `)`   | (regular application)        |
|              | &bar; | _appexpr_ _lidx_ [_arguments_]{.opt} `]`   | (index operation)            |
|              | &bar; | _appexpr_ [_funexpr_]{.many}               | (apply function expressions) |
|              | &bar; | _appexpr_ `.` _atom_                       |                              |
|              | &bar; | _atom_                                     |                              |
| &nbsp;       |       |                                            |                              |
| _arguments_  | ::=   | _argument_ [`,` _argument_]{.many}         |                              |
| _argument_   | ::=   | [_identifier_ `=`]{.opt} _expr_            |                              |
{.grammar .parse}


### Atomic expressions

| ~~~~~~~~~~~~ | ~~~~~~~~ | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
| _atom_       | ::=      | _qidentifier_                                                  |                              |
|              | &bar;    | _qconstructor_                                                 |                              |
|              | &bar;    | _literal_                                                      |                              |
|              | &bar;    | `(` `)`                                                        | (unit)                       |
|              | &bar;    | `(` _annexpr_ `)`                                              | (parenthesized expression)   |
|              | &bar;    | `(` _annexprs_ `)`                                             | (tuple expression)           |
|              | &bar;    | `[` [_annexpr_ [`,` _annexprs_]{.many} [`,`]{.opt} ]{.opt} `]`  | (list expression)            |
| &nbsp;       |          |                                                                |                              |
| _literal_    | ::=      | _natural_ []{.bar} _float_ []{.bar} _char_ []{.bar} _string_   |                              |
| &nbsp;       |          |                                                                |                              |
| _annexprs_   | ::=      | _annexpr_ [`,` _annexpr_]{.many}                               |                              |
| _annexpr_    | ::=      | _expr_ [``:`` _typescheme_]{.opt}                                |                              |
{.grammar .parse}

### Matching

| ~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _matchrule_ | ::=   | _patterns_ ``\(&bar;\)`` _expr_ `->` _blockexpr_ |                                              |
|             | &bar; | _patterns_ _bodyexpr_                                    |                                              |
| &nbsp;      |       |                                                          |                                              |
| _apattern_  | ::=   | _pattern_ [`:` _typescheme_]{.opt}                       |                                              |
| _pattern_   | ::=   | _identifier_                                             |                                              |
|             | &bar; | _wildcard_                                               |                                              |
|             | &bar; | _qconstructor_ [_lparen_ [_patargs_]{.opt} `)`]          |                                              |
|             | &bar; | `(` [_apatterns_]{.opt} `)`                              | (unit, parenthesized pattern, tuple pattern) |
|             | &bar; | `[` [_apatterns_]{.opt} `]`                              | (list pattern)                               |
|             | &bar; | _apattern_ `as` _identifier_                             | (named pattern)                              |
|             | &bar; | _literal_                                                |                                              |
| &nbsp;      |       |                                                          |                                              |
| _patterns_  | ::=   | _pattern_ [`,` _pattern_]{.many}                         |                                              |
| _apatterns_ | ::=   | _apattern_ [`,` _apattern_]{.many}                       |                                              |
| _patargs_   | ::=   | _patarg_ [`,` _patarg_]{.many}                           |                                              |
| _patarg_    | ::=   | [_identifier_ `=`]{.opt} _apattern_                      | (possibly named parameter)                   |
{.grammar .parse}

### Handlers

| ~~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~|
| _handlerrules_ | ::=   | _semis_ _handlerrule_ [_semis_ _handlerrule_]{.many} semis     |    |
| _handlerrule_  | ::=   | _qidentifier_ _opargs_ _bodyexpr_                              |    |
|                | &bar; | `return`  (_lparen_ _oparg_ `)` []{.bar} _paramid_) _bodyexpr_ |    |
| &nbsp;         |       |                                                                |    |
| _opargs_       | &bar; | _lparen_ [_oparg_ [`,` _oparg_]{.many}]{.opt} `)`              |    |
| _oparg_        | &bar; | _paramid_ [``:`` _type_]{.opt}                                 |    |
{.grammar .parse}

### Type schemes

|~~~~~~~~~~~~~~~~|~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~|~~~~~|
| _typescheme_   | ::= | _somes_ _foralls_ _tarrow_ [_qualifier_]{.opt}    |             |     |
| _type_         | ::= | _foralls_ _tarrow_ [_qualifier_]{.opt}    |             |     |
| &nbsp;         |     |                                                       |             |     |
| _foralls_      | ::= | [`forall` _typeparams_]{.opt}           |             |     |
| _some_         | ::= | [`some` _typeparams_]{.opt}           |             |     |
| &nbsp;         |     |                                                       |             |     |
| _qualifier_    | ::= | `with` `(` _predicates_ `)`                           |             |     |
| &nbsp;         |     |                                                       |             |     |
| _predicates_   | ::= | _predicate_ [`,` _predicate_]{.many}                  |             |     |
| _predicate_    | ::= | _typeapp_                                             | (interface) |     |
{.grammar .parse}

### Types

|~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _tarrow_  | ::=    | _tatom_ [`->` _tresult_]{.opt}                                                 |                                        |
| _tresult_ | ::=    | _tatom_ [_tbasic_]{.opt}                                                       |                                        |
| &nbsp;    |        |                                                                                |                                        |
| _tatom_   | ::=    | _tbasic_                                                                       |                                        |
|           | &bar;  | `<` _anntype_ [`,` _anntype_]{.many} [``\(&bar;\)`` _tatom_]{.opt} `>` |                                        |
|           | &bar;  | `<` `>`                                                                        |                                        |
| &nbsp;    |        |                                                                                |                                        |
| _tbasic_  | ::=    | _typeapp_                                                                      |                                        |
|           | &bar;  | `(` `)`                                                                        | (unit type)                            |
|           | &bar;  | `(` _tparam_ `)`                                                               | (parenthesized type or type parameter) |
|           | &bar;  | `(` _tparam_ [`,` _tparam_]{.many} `)`                                         | (tuple type or parameters)             |
|           | &bar;  | `[` _anntype_ `]`                                                              | (list type)                            |
| &nbsp;    |        |                                                                                |                                        |
| _typeapp_ | ::=    | _typecon_ [`<` _anntype_ [`,` _anntype_]{.many} `>`]{.opt}                     |                                        |
| &nbsp;    |        |                                                                                |                                        |
| _typecon_ | ::=    | _varid_ []{.bar} _qvarid_                                                      |                                        |
|           | &bar;  | _wildcard_                                                                     |                                        |
|           | &bar;  | `(` `,` [`,`]{.many} `)`                                                       | (tuple constructor)                    |
|           | &bar;  | `[` `]`                                                                        | (list constructor)                     |
|           | &bar;  | `(` `->` `)`                                                                   | (function constructor)                 |
| &nbsp;    |        |                                                                                |                                        |
| _tparam_  | ::=    | [_varid_ ``:``]{.opt} _anntype_                                                  |                                        |
| _anntype_ | ::=    | _type_ [_kannot_]{.opt}                                                        |                                        |
{.grammar .parse}

### Kinds

|~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~|
| _kannot_ | ::=    | ``::`` _kind_                                    |                  |
| &nbsp;   |        |                                                |                  |
| _kind_   | ::=    | `(` _kind_ [`,` _kind_]{.many} `)` `->` _kind_ |                  |
|          | &bar;  | _katom_ `->` _kind_                            |                  |
|          | &bar;  | _katom_                                        |                  |
| &nbsp;   |        |                                                |                  |
| _katom_  | ::=    | `V`                                            | (value type)     |
|          | &bar;  | `X`                                            | (effect type)    |
|          | &bar;  | `E`                                            | (effect row)     |
|          | &bar;  | `H`                                            | (heap type)      |
|          | &bar;  | `P`                                            | (predicate type) |
{.grammar .parse}

### Implementation

As a companion to the Flex lexical implementation, there is a full 
Bison(Yacc) LALR(1) [implementation][BisonGrammar] 
available. Again, the Bison parser functions
as _the_ specification of the grammar and this document should always
be in agreement with that implementation.

  [BisonGrammar]: https://koka.codeplex.com/SourceControl/latest#doc/spec/grammar/parser.y
  [FlexLexer]:    https://koka.codeplex.com/SourceControl/latest#doc/spec/grammar/lexer.lex
