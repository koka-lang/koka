
# &koka; language specification

This is the draft language specification of the &koka; language, version v&kokaversion;\
Currently only the lexical and context-free grammar are specified.
The [standard libraries][stdlib] are documented separately.

[stdlib]: toc.html

## Lexical syntax

We define the grammar and lexical syntax of the language using standard BNF
notation where non-terminals are generated by alternative patterns:

|~~~~~~~~~~~|~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~|
| _nonterm_ | ::= | _pattern_~1~ &bar; _pattern_~2~ |   |
{.grammar}

In the patterns, we use the following notations:

|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| `terminal`                         |   | A terminal symbol (in ASCII)                                               |
| ``x1B``                            |   | A character with hexadecimal code 1B                                       |
| ``A..F``                           |   | The characters from "A" to "F" (using ASCII, i.e. ``x61..x66``)            |
| &nbsp;                             |   |                                                                            |
| ( _pattern_ )                      |   | Grouping                                                                   |
| [ _pattern_ ]                      |   | Optional occurrence of _pattern_                                           |
| { _pattern_ }                      |   | Zero or more occurrences of _pattern_                                      |
| { _pattern_ }~_n_~                 |   | Exactly _n_ occurrences of _pattern_                                       |
| _pattern_~1~ &bar; _pattern_~2~    |   | Choice: either _pattern_~1~ or _pattern_~2~                                |
| &nbsp;                             |   |                                                                            |
| _pattern_[_diff_]{.diff}           |   | Difference: elements generated by _pattern_ except those in _diff_         |
| _nonterm_~[\/_lex_]~               |   | Generate _nonterm_ by drawing lexemes from _lex_                           |
{.grammar}


Care must be taken to distinguish meta-syntax such as &bar; and )
from concrete terminal symbols as ``|`` and ``)``. In the specification
the order of the productions is not important and at each point the
_longest matching lexeme_ is preferred. For example, even though
`fun` is a reserved word, the word `functional` is considered a
single identifier.
{.grammar}

### Source code

Source code consists of a sequence of unicode characters. Valid characters in
actual program code consist strictly of ASCII characters which range from 0 to 127. 
Only comments, string literals, and character literals are allowed to
contain extended unicode characters. The grammar is designed such that a lexical
analyzer and parser can directly work on UTF-8 encoded source files without
actually doing UTF-8 decoding or unicode category identification.

## Lexical grammar

In the specification of the lexical grammar all white space is explicit
and there is no implicit white space between juxtaposed symbols. The
lexical token stream is generated by the non-terminal _lex_ which
consists of lexemes and whitespace.

Before doing lexical analysis, there is a _linefeed_ character inserted
at the start and end of the input, which makes it easier to specify line
comments and directives.

### Lexical tokens { test }

| ~~~~~~~~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~|
| _lex_                | ::=   | _lexeme_ &bar; _whitespace_                               |     |
| _lexeme_&nbsp;&nbsp; | ::=   | _conid_ &bar; _qconid_                                    |     |
|                      | &bar; | _varid_ &bar; _qvarid_                                    |     |
|                      | &bar; | _op_ &bar; _opid_ &bar; _qopid_ &bar; _wildcard_          |     |
|                      | &bar; | _integer_ &bar; _float_ &bar; _stringlit_ &bar; _charlit_ |     |
|                      | &bar; | _reserved_ &bar; _opreserved_                             |     |
|                      | &bar; | _special_                                                 |     |
{.grammar .lex}

The main program consists of _whitespace_ or _lexeme_'s. The context-free
grammar will draw it's lexemes from the _lex_ production.

### Identifiers

|~~~~~~~~~~~~~~|~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~|
| _anyid_      | ::=   | _varid_ &bar; _qvarid_ &bar; _opid_ &bar; _qopid_ &bar; _conid_ &bar; _qconid_ |                         |
| &nbsp;       |       |                                                                                               |                         |
| _qconid_     | ::=   | _modulepath_ _conid_                                                                          |                         |
| _qvarid_     | ::=   | _modulepath_ _lowerid_                                                                        |                         |
| _modulepath_ | ::=   | _lowerid_ `/` [_lowerid_ `/`]{.many}                                                          |                         |
| &nbsp;       |       |                                                                                               |                         |
| _conid_      | ::=   | _upperid_                                                                                     |                         |
| _varid_      | ::=   | _lowerid_[_reserved_]{.diff}                                                               |                         |
| &nbsp;       |       |                                                                                               |                         |
| _lowerid_    | ::=   | _lower_ _idtail_                                                                              |                         |
| _upperid_    | ::=   | _upper_ _idtail_                                                                              |                         |
| _wildcard_   | ::=   | ``_`` _idtail_                                                                                |                         |
| _typevarid_  | ::=   | _letter_ [_digit_]{.many}                                                                     |                         |
| &nbsp;       |       |                                                                                               |                         |
| _idtail_     | ::=   | [_idchar_]{.many} [_idfinal_]{.opt}                                                           |                         |
| _idchar_     | ::=   | _letter_ &bar; _digit_ &bar; ``_`` &bar; ``-``                                       |                         |
| _idfinal_    | ::=   | [``'``]{.many}                                                                                |                         |
| &nbsp;       |       |                                                                                               |                         |
| _reserved_   | ::=   | `infix` &bar; `infixr` &bar; `infixl`                                                   |                         |
|              | &bar; | ``module`` &bar; `import` &bar; `as`                                                    |                         |
|              | &bar; | ``pub`` &bar; `abstract`                                                                   |                         |
|              | &bar; | `type` &bar; `struct` &bar; `alias` &bar; `effect` &bar; `con`                    |                         |
|              | &bar; | `forall` &bar; `exists` &bar; `some`                                                    |                         |
|              | &bar; | `fun` &bar; `fn` &bar; `val` &bar; `var` &bar; `extern`                           |                         |
|              | &bar; | `if` &bar; `then` &bar; `else` &bar; `elif`                                          |                         |
|              | &bar; | `match` &bar; `return` &bar; `with` &bar; `in`                                       |                         |
|              | &bar; | `handle` &bar; `handler` &bar; `mask`                                                   |                         |
|              | &bar; | `ctl` &bar; `final` &bar; `raw`                                     |                         |
|              | &bar; | `override` &bar; `named`                                        |                         |
|              | &bar; | `interface` &bar; `break` &bar; `continue` &bar; `unsafe`        | (future reserved words) |
| &nbsp;       |       |                                                                           |                         |
| _specialid_  | ::=   | `co` &bar; `rec` &bar; `open` &bar; `extend` &bar; `behind`   |                         |
|              | &bar; | `linear` &bar; `scoped` &bar;                                 |                     |
|              | &bar  | `value` &bar; `reference` &bar; `ref`           |                         |
|              | &bar; | `fip` &bar; `fbip` &bar; `tail`                                                   |                         |
|              | &bar; | `inline` &bar; `noinline` &bar; `initially` &bar; `finally`      |                         |
|              | &bar; | `js` &bar; `c` &bar; `cs` &bar; `file`                           |                         |
{.grammar .lex}

Identifiers always start with a letter, may contain underscores and
dashes, and can end with prime ticks.
Like in Haskell, constructors always begin with an uppercase
letter while regular identifiers are lowercase. The rationale is to
visibly distinguish constants from variables in pattern matches.
Here are some example of valid identifiers:
```unchecked
x
concat1
visit-left
is-nil
x'
Cons
True  
```
To avoid confusion with the subtraction operator, the occurrences of
dashes are restricted in identifiers. After lexical analysis, only
identifiers where each dash is surrounded on both sides with a _letter_
are accepted:

````koka
fold-right
n-1        // illegal, a digit cannot follow a dash
n - 1      // n minus 1
n-x-1      // illegal, a digit cannot follow a dash
n-x - 1    // identifier "n-x" minus 1
n - x - 1  // n minus x minus 1
````
Qualified identifiers are prefixed with a module path. Module
paths can be partial as long as they are unambiguous.

````koka
core/map
std/core/(&)
````

### Operators and symbols

| ~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~|
| _qopid_      | ::=   | _modulepath_ _opid_                                                                                                                                   |    |
| _opid_       | ::=   | `(` _symbols_ `)`                                                                                                                                     |    |
| &nbsp;       |       |                                                                                                                                                       |    |
| _op_         | ::=   | _symbols_[_opreserved_ &bar; _optype_]{.diff}  &bar;  ``\(&bar;&bar;\)``                                                                      |    |
| &nbsp;       |       |                                                                                                                                                       |    |
| _symbols_    | ::=   | _symbol_ [_symbol_]{.many}&bar; ``/``                                                                                                             |    |
| _symbol_     | ::=   | `$` &bar; `%` &bar; ``&`` &bar; `*` &bar; `+`                                                                                             |    |
|              | &bar; | ``~`` &bar; ``!`` &bar; ``\`` &bar; `^` &bar; ``#``                                                                                       |    |
|              | &bar; | ``=`` &bar; ``.`` &bar; ``:`` &bar; `-` &bar; `?`                                                                                         |    |
|              | &bar; | _anglebar_                                                                                                                                            |    |
| _anglebar_   | ::=   | ``<`` &bar; ``>`` &bar; ``\(&bar;\)``                                                                                                           |    |
| &nbsp;       |       |                                                                                                                                                       |    |
| _opreserved_ | ::=   | `=` &bar; `.` &bar; ``:`` &bar; `->`                                                                                                         |    |
| _optype_     | ::=   | _anglebar_ _anglebar_ [_anglebar_]{.many}                                                                                                             |    |
| &nbsp;       |       |                                                                                                                                                       |    |
| _special_    | ::=   | `{` &bar; `}` &bar; `(` &bar; `)` &bar; `[` &bar; `]` &bar; ``\(&bar;\)`` &bar; `;` &bar; `,`                                 |    |
| &nbsp;       |       |                                                                                                                                                       |    |
{.grammar .lex}

### Literals

|~~~~~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~|
| _charlit_     | ::=    | ``'`` (_char_[``'`` &bar; ``\``]{.diff} &bar; _escape_) ``'``                  |              |
| _stringlit_   | ::=    | ``"`` [_char_[``"`` &bar; ``\``]{.diff} &bar; _escape_]{.many} ``"``             |              |
|               | &bar;  | ``r`` [``#``]{.manyn} ``"`` _rawchars_~_n_~ ``"`` [``#``]{.manyn}  |  (n >= 0)            |                 
| _rawchars_~_n_~ | ::=    | [_anychar_]{.many}[[_anychar_]{.many} ``"`` [``#``]{.manyn} [_anychar_]{.many}]{.diff} |             |                 
| &nbsp;        |        |                                                                                                                           |              |
| _escape_      | ::=    | ``\`` ( _charesc_ &bar; _hexesc_ )                                                                                     |              |
| _charesc_     | ::=    | `n` &bar; `r` &bar; `t` &bar; ``\`` &bar; ``"`` &bar; ``'``                                                |              |
| _hexesc_      | ::=    | `x` [_hexdigit_]{.manyx}~2~ &bar;   `u` [_hexdigit_]{.manyx}~4~ &bar;   ``U`` [_hexdigit_]{.manyx}~6~                  |              |
| &nbsp;        |        |                                                                                                                           |              |
| _float_       | ::=    | [``-``]{.opt} (decfloat &bar; hexfloat)                                                                                |              |
| _decfloat_    | ::=    | _decimal_ (`.` _digits_ [_decexp_]{.opt} &bar; _decexp_)                                                                               |              |
| _decexp_      | ::=    | (``e`` &bar;  ``E``) _exponent_                                                                      |              |
| _hexfloat_    | ::=    | _hexadecimal_ (`.` _hexdigits_ [_hexexp_]{.opt} &bar; _hexexp_)                                                                               |              |
| _hexexp_      | ::=    | (``p`` &bar; ``P``) _exponent_                                                                      |              |
| _exponent_    | ::=    | [``-`` &bar; ``+``]{.opt} _digit_ [_digit_]{.many}                                                                    |              |
| &nbsp;        |        |                                                                                                                           |              |
| _integer_     | ::=    | [``-``]{.opt} (_decimal_ &bar; _hexadecimal_)                                                              |              |
| _decimal_     | ::=    | ``0`` &bar; _posdigit_ [[``_``]{.opt} _digits_]{.opt}                                                                                                  |              |
| _hexadecimal_ | ::=    | ``0`` (``x`` &bar; ``X``) _hexdigits_                                                                                           |              |
| _digits_      | ::=    | _digit_ [_digit_]{.many} [``_`` _digit_ [_digit_]{.many}]{.many}                                                                                                 |              |
| _hexdigits_   | ::=    | _hexdigit_ [_hexdigit_]{.many} [``_`` _hexdigit_ [_hexdigit_]{.many}]{.many}                                                                                                 |              |
{.grammar .lex}

### White space

|~~~~~~~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _whitespace_    | ::=    | _white_ [_white_]{.many} &bar; _newline_                                                                           |                          |
| _white_         | ::=    | _space_                                                                         |                          |
|                 | &bar;  | _linecomment_ &bar; _blockcomment_                                                              |                          |
|                 | &bar;  | _linedirective_                                                                                    |                          |
| &nbsp;          |        |                                                                                                    |                          |
| _linecomment_   | ::=    | ``//`` [_char_ &bar; _tab_]{.many}                                                                  |                          |
| _linedirective_ | ::=    | _newline_ ``#`` [_char_ &bar; _tab_]{.many}                                            |                          |
| &nbsp;          |        |                                                                                                    |                          |
| _blockcomment_  | ::=    | <code>/&#42;</code> _blockpart_ [_blockcomment_ _blockpart_]{.many} <code>&#42;/</code>            | (allows nested comments) |
| _blockpart_     | ::=    | [_anychar_]{.many}[[_anychar_]{.many}\ (<code>/&#42;</code>&bar;<code>&#42;/</code>)\ [_anychar_]{.many}]{.diff} |                          |
{.grammar .lex}

### Character classes

|~~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _letter_   | ::=    | _upper_ &bar; _lower_                |                                     |
| _upper_    | ::=    | ``A..Z``                                |  (i.e. ``x41..x5A``)                |
| _lower_    | ::=    | ``a..z``                                |  (i.e. ``x61..x7A``)                |
| _digit_    | ::=    | ``0..9``                                |  (i.e. ``x30..x39``)                |
| _posdigit_ | ::=    | ``1..9``                                |                                     |
| _hexdigit_ | ::=    | ``a..f`` &bar; ``A..F`` &bar; _digit_   |                                     |
| &nbsp;     |        |                                         |                                     |
| _anychar_  | ::=    | _char_ &bar; _tab_ &bar; _newline_      | (in comments and raw strings)       |
| _newline_  | ::=    | [_return_]{.opt} _linefeed_             | (windows or unix style end of line) |
| &nbsp;     |        |                                         |                                     |
| _space_    | ::=    | ``x20``                                 | (a space)                           |
| _tab_      | ::=    | ``x09``                                 | (a tab (``\t``))                    |
| _linefeed_ | ::=    | ``x0A``                                 | (a line feed (``\n``))              |
| _return_   | ::=    | ``x0D``                                 | (a carriage return (``\r``))        |
| &nbsp;     |        |                                         |                                     |
| _char_     | ::=    | _unicode_[_control_ &bar; _surrogate_ &bar; _bidi_]{.diff} | (includes _space_) |
| _unicode_  | ::=    | ``x00..x10FFFF``                        |                                     | 
| _control_  | ::=    | ``x00..x1F`` &bar; ``x7F`` &bar; ``x80..9F`` | (C0, DEL, and C1)              | 
| _surrogate_| ::=    | ``xD800..xDFFF``                        |                                     |
| _bidi_     | ::=    | ``x200E`` &bar; ``x200F`` &bar; ``x202A..x202E`` &bar; ``x2066..x2069`` | (bi-directional text control)   |
{.grammar .lex}

Actual program code consists only of 7-bit ASCII characters while only comments
and literals can contain extended unicode characters. As such, 
a lexical analyzer can directly process UTF-8 encoded input as
a sequence of bytes without needing UTF-8 decoding or unicode character 
classification[^fn-utf8]. 
For security
[@Boucher:trojan], some character ranges are excluded: the C0 and C1 
[control codes](https://en.wikipedia.org/wiki/C0_and_C1_control_codes) (except for space,
tab, carriage return, and line feeds), surrogate characters, and bi-directional
text control characters.


[^fn-utf8]: This is used for example in the [Flex][FlexLexer] implementation.
    In particular, we only need to adapt the _char_ definition:

    |~~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
    | _char_     | ::=    | _unicode_[_control_ &bar; _surrogate_ &bar; _bidi_]{.diff}  |               |
    | _unicode_  | ::=    | ``x00..x7F``                            | (ASCII)                                    |
    |            | &bar;  | (``xC2..xDF``) _cont_                   |                                     |
    |            | &bar;  | ``xE0`` (``xA0..xBF``) _cont_           | (exclude overlong encodings)        |
    |            | &bar;  | (``xE1..xEF``) _cont_ _cont_            |                                     |
    |            | &bar;  | ``xF0`` (``x90..xBF``) _cont_ _cont_    | (exclude overlong encodings)        |
    |            | &bar;  | (``xF1..xF3``) _cont_ _cont_ _cont_     |                                     |
    |            | &bar;  | ``xF4`` (``x80..x8F``) _cont_ _cont_    | (no codepoint larger than ``x10FFFF``)  |
    | _cont_     | ::=    | ``x80..xBF``                            |                                     |
    | _surrogate_| ::=    | ``xED`` (``xA0..xBF``) _cont_           |                                     |
    | _control_  | ::=    | ``x00..x1F``                            |  
    |            | &bar;  | ``x7F``                                 |                                     |
    |            | &bar;  | ``xC2`` (``x80..x9F``)                  |                                     |
    | _bidi_     | ::=    | ``xE2`` ``0x80`` (``0x8E..0x8F``)       | (left-to-right mark (``u200E``) and right-to-left mark (``u200F``))              |
    |            | &bar;  | ``xE2`` ``0x80`` (``0xAA..0xAE``)       | (left-to-right embedding (``u202A``) up to right-to-left override (``u202E``))   |
    |            | &bar;  | ``xE2`` ``0x81`` (``0xA6..0xA9``)       | (left-to-right isolate (``u2066``) up to pop directional isolate (``u2069``))|
    {.grammar .lex}


[utf8unsafe]: https://arxiv.org/pdf/2111.00169.pdf
[bidi]: https://en.wikipedia.org/wiki/Bidirectional_text

## Layout  {#sec-layout}

[Haskell]: http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3  
[Python]: http://docs.python.org/2/reference/lexical_analysis.html
[JavaScript]: https://tc39.github.io/ecma262/#sec-rules-of-automatic-semicolon-insertion
[Scala]: http://www.scala-lang.org/old/sites/default/files/linuxsoft_archives/docu/files/ScalaReference.pdf#page=13
[Go]: http://golang.org/ref/spec#Semicolons


Just like programming languages like
[Haskell], [Python], [JavaScript], [Scala], [Go], etc., there is a layout rule
which automatically adds braces and semicolons at appropriate places:

* Any block that is _indented_ is automatically wrapped with curly braces:
  ```
  fun show-messages1( msgs : list<string> ) : console ()  
    msgs.foreach fn(msg)
      println(msg)
  ```
  is elaborated to:
  ```unchecked
  fun show-messages1( msgs : list<string> ) : console () {
    msgs.foreach fn(msg) {
      println(msg)
    }
  }
  ```

* Any statements and declarations that are _aligned_ in a block are terminated with semicolons, that is:
  ```
  fun show-messages2( msgs : list<string> ) : console ()  
    msgs.foreach fn(msg)
      println(msg)
      println("--")
    println("done")
  ```
  is fully elaborated to:
  ```unchecked
  fun show-messages2( msgs : list<string> ) : console () {
    msgs.foreach fn(msg){
      println(msg);
      println("--");
    };
    println("done");
  }
  ```

* Long expressions or declarations can still be indented without getting braces or semicolons
  if it is clear from the start- or previous token that the line continues
  an expression or declaration. Here is a contrived example:
  ```
  fun eq2( x : int, 
            y : int ) : io bool  
    print("calc " ++
          "equ" ++
          "ality")
    val result = if (x == y)
                  then True
                  else False
    result  
  ```
  is elaborated to:
  ```unchecked
  fun eq2( x : int, 
            y : int ) : io bool {  
    print("calc " ++
          "equ" ++
          "ality");
    val result = if (x == y)
                  then True
                  else False;
    result
  }
  ```
  Here the long string expression is indented but no braces or semicolons
  are inserted as the previous lines end with an operator (`++`).
  Similarly, in the `if` expression no braces or semicolons are inserted
  as the indented lines start with `then` and `else` respectively.
  In the parameter declaration, the `,` signifies the continuation.  
  More precisely, for long expressions and declarations, indented or aligned lines 
  do not get braced or semicolons if:

  1. The line starts with a clear expression or declaration _start continuation token_,
    namely: an operator (including `.`), `then`, `else`, `elif`, 
    a closing brace (`)`, `>`, `]`, or `}`), 
    or one of `,`, `->`, `{` , `=`, `|`, `::`, `.`, `:=`.
  2. The previous line ends with a clear expression or declaration _end continuation token_,
    namely an operator (including `.`), an open brace (`(`, `<`, `[`, or `{`), or `,`.

The layout algorithm is performed on the token stream in-between lexing
and parsing, and is independent of both. In particular, there are no intricate 
dependencies with the parser (which leads to very complex layout rules, as is the 
case in languages like [Haskell] or [JavaScript]).

Moreover, in contrast to purely token-based layout rules (as in [Scala] or [Go] for example), 
the visual indentation in a Koka program corresponds directly to how the compiler 
interprets the statements. Many tricky layout
examples in other programming languages are often based on a mismatch between
the visual representation and how a compiler interprets the tokens -- with
&koka;'s layout rule such issues are largely avoided. 

Of course, it is still allowed to explicitly use semicolons and braces, 
which can be used for example to put multiple statements on a single line:

```
fun equal-line( x : int, y : int ) : io bool {
  print("calculate equality"); (x == y)
}  
```

The layout algorithm also checks for invalid layouts where the layout would
not visually correspond to how the compiler interprets the tokens. In
particular, it is illegal to indent less than the layout context or to put
comments into the indentation (because of tabs or potential unicode
characters). For example, the program:

```unchecked
fun equal( x : int, y : int ) : io bool {   
    print("calculate equality")
  result = if (x == y) then True   // wrong: too little indentation
  /* wrong */      else False
    result
}  
```

is rejected. In order to facilitate code generation or source code
compression, compilers are also required to support a mode where the layout
rule is not applied and no braces or semicolons are inserted. A recognized command
line flag for that mode should be ``--nolayout``.

### The layout algorithm

To define the layout algorithm formally, we first establish some terminology:

* A new line is started after every _linefeed_ character.
* Any non-_white_ token is called a _lexeme_, where a line without lexemes
  is called _blank_.
* The indentation of a lexeme is the column number of its first character on
  that line (starting at 1), and the indentation of a line is the indentation
  of the first lexeme on the line.
* A lexeme is an _expression continuation_ if it is the first lexeme on a line,
  and the lexeme is a _start continuation token_, or the previous lexeme is an
  _end continuation token_ (as defined in the previous section).

Because braces can be nested, we use a _layout stack_ of strictly
increasing indentations. The top indentation on the layout stack holds the
_layout indentation_. The initial layout stack contains the single
value 0 (which is never popped). We now proceed through the token stream
where we perform the following operations in order: first brace insertion,
then layout stack operations, and finally semicolon insertion:

* _Brace insertion_: For each non-blank line, consider the first lexeme on the line.
  If the indentation is larger than the layout indentation, and the lexeme
  is not an _expression continuation_, then insert an open brace `{` before the lexeme.
  If the indention is less than the layout indentation, and the lexeme is not already a
  closing brace, insert a closing brace `}` before the lexeme.

* _Layout stack operations_: If the previous lexeme was an
  open brace `{` or the start of the lexical token sequence, we push the
  indentation of the current lexeme on the layout stack. The pushed indentation
  must be larger than the previous layout indentation (unless the current lexeme
  is a closing brace).  When a closing brace `}` is encountered the top
  indentation is popped from the layout stack.

* _Semicolon insertion_: For each non-blank line, the
  indentation must be equal or larger to the layout indentation. 
  If the indentation is equal to the layout indentation, and the first
  lexeme on the line is not an _expression continuation_, a semicolon
  is inserted before the lexeme. 
  Also, a semicolon is always inserted before a closing brace `}` and
  before the end of the token sequence.
{.grammar}

As defined, braces are inserted around any indented blocks, semicolons 
are inserted whenever statements or declarations are
aligned (unless the lexeme happens to be a clear expression continuation). To
simplify the grammar specification, a semicolon is also always inserted before
a closing brace and the end of the source. This allows us to specify many
grammar elements as ended by semicolons instead of separated by semicolons
which is more difficult to specify for a LALR(1) grammar.

The layout can be implemented as a separate transformation on the lexical token
stream (see the 50 line [Haskell][HaskellLayout] implementation in the Koka compiler),
or directly as part of the lexer (see the [Flex][FlexLexer] implementation)

### Implementation { #sec:lex-implementation }

There is a full [Flex (Lex) implementation][FlexLexer] of lexical
analysis and the layout algorithm.
Ultimately, the Flex implementation serves as _the_
specification, and this document and the Flex implementation should
always be in agreement.

## Context-free syntax

The grammar specification starts with the non terminal _module_ which draws
its lexical tokens from _lex_ where all _whitespace_ tokens are implicitly
ignored.

### Modules

|~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~|
| _module_~[_lex_]{.opt}~ | ::=   | [_moduledecl_]{.opt} _modulebody_                 |   |
| &nbsp;                  |       |                                                   |   |
| _moduledecl_            | ::=   | _semis_  `module` _moduleid_                      |   |
| _moduleid_              | ::=   | _qvarid_ &bar; _varid_                         |   |
| &nbsp;                  |       |                                                   |   |
| _modulebody_            | ::=   | `{` _semis_ _declarations_ `}` _semis_            |   |
|                         | &bar; | _semis_ _declarations_                            |   |
| &nbsp;                  |       |                                                   |   |
| _semis_                 | ::=   | [`;`]{.many}                                      |   |
| _semi_                  | ::=   | `;` _semis_                                       |   |
{.grammar .parse}

### Top level declarations

|~~~~~~~~~~~~~~~~|~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~|
| _declarations_ | ::=   | [_importdecl_]{.many} [_fixitydecl_]{.many} _topdecls_                                    |   |
| &nbsp;         |       |                                                                                       |   |
| _importdecl_   | ::=   | [ _pub_]{.opt} `import` [_moduleid_ `=`]{.opt} _moduleid_ _semi_                      |   |
| &nbsp;         |       |                                                                                       |   |
| _fixitydecl_   | ::=   | [ _pub_]{.opt} _fixity_ _integer_ _identifier_ [`,` _identifier_]{.many} _semi_       |   |
| _fixity_       | ::=   | `infixl` &bar; `infixr` &bar; `infix`                                                 |   |
| &nbsp;         |       |                                                                                       |   |
| _topdecls_     | ::=   | [_topdecl_ _semi_]{.many}                                                             |   |
| _topdecl_      | ::=   | [ _pub_]{.opt} _puredecl_                                                             |   |
|                | &bar; | [ _pub_]{.opt} _aliasdecl_                                                            |   |
|                | &bar; | [ _pub_]{.opt} _externdecl_                                                           |   |
|                | &bar; | [ _pubabstract_]{.opt} _typedecl_                                                     |   |
|                | &bar; | [ _pubabstract_]{.opt} _effectdecl_                                                   |   |
| &nbsp;         |       |                                                                                       |   |
| _pub_          | ::=   | `pub`                                                                                 |   |
| _pubabstract_  | ::=   | `pub` &bar; `abstract`                                                                |   |
{.grammar .parse}

### Type Declarations

| ~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~|
| _aliasdecl_   | ::=   | `alias` _typeid_ [_typeparams_]{.opt} [_kannot_]{.opt} `=` _type_                                          |    |
| &nbsp;        |       |                                                                                                            |    |
| _typedecl_    | ::=   | _typemod_ `type` _typeid_ [_typeparams_]{.opt} [_kannot_]{.opt} [_typebody_]{.opt}                         |    |
|               | &bar; | _structmod_ `struct` _typeid_ [_typeparams_]{.opt} [_kannot_]{.opt} [_conparams_]{.opt}                    |    |
| &nbsp;        |       |                                                                                                            |    |
| _typemod_     | ::=   | `co` &bar; `rec` &bar; `open` &bar; `extend` &bar; _structmod_                                 |    |
| _structmod_   | ::=   | `value` &bar; `reference`                                                                               |    |
| &nbsp;        |       |                                                                                                            |    |
| _typeid_      | ::=   | _varid_ &bar; ``[]`` &bar; `(` [`,`]{.many} `)` &bar; `<` `>` &bar; `<` [&bar;]{.koka; .code} `>`          |    |
| &nbsp;        |       |                                                                                                            |    |
| _typeparams_  | ::=   | `<` [_tbinders_]{.opt} `>`                                                                                 |    |
| _tbinders_    | ::=   | _tbinder_ [`,` _tbinder_]{.many}                                                                           |    |
| _tbinder_     | ::=   | _varid_ [_kannot_]{.opt}                                                                                   |    |
| _typebody_    | ::=   | `{` _semis_ [_constructor_ _semi_]{.many} `}`                                                              |    |
| &nbsp;        |       |                                                                                                            |    |
| _constructor_ | ::=   | [ _pub_]{.opt} [`con`]{.opt} _conid_ [_typeparams_]{.opt} [_conparams_]{.opt}                              |    |
| _conparams_   | ::=   | `{` _semis_ [_parameter_ _semi_]{.many} `}`                                                                |    |
{.grammar .parse}

### Value and Function Declarations

| ~~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~|
| _puredecl_     | ::=   | [_inlinemod_]{.opt} `val` _valdecl_                                                   |                      |
|                | &bar; | [_inlinemod_]{.opt} [_fipmod_]{.opt} `fun` _fundecl_                                                   |                      |
| _inlinemod_    | ::=   | `inline` &bar; `noinline`                                                  |                      |
| _fipalloc_     | ::=   | `(` _integer_ `)` &bar;  `(` `n` `)`                                          | (n means finitely)     |
| _fipmod_       | ::=   | `fip` [_fipalloc_]{.opt} &bar; `fbip` [_fipalloc_]{.opt} &bar; `tail`         |                      |
| &nbsp;         |       |                                                                               |                      |
| _valdecl_      | ::=   | _binder_ `=` _blockexpr_                                                           |                      |
| _binder_       | ::=   | _identifier_ [``:`` _type_]{.opt}                                             |                      |
| &nbsp;         |       |                                                                               |                      |
| _fundecl_      | ::=   | _funid_ _funbody_                                                |                      |
| _funbody_      | ::=   | _funparam_ _blockexpr_                                                |                      |
| _funparam_     | ::=   | [_typeparams_]{.opt} _pparameters_ [``:`` _tresult_]{.opt} [_qualifier_]{.opt} |                      |
| _funid_        | ::=   | _identifier_                                                                  |                      |
|                | &bar; | ``[`` [`,`]{.many} ``]``                                                      | (indexing operator)  |
| &nbsp;         |       |                                                                               |                      |
| _parameters_   | ::=   | `(` [_parameter_ [`,` _parameter_]{.many}]{.opt} `)`                          |                      |
| _parameter_    | ::=   | [_borrow_]{.opt} _paramid_ [``:`` _type_]{.opt} [`=` _expr_]{.opt}            |                      |
| &nbsp;         |       |                                                                               |                      |
| _pparameters_   | ::=   | `(` [_pparameter_ [`,` _pparameter_]{.many}]{.opt} `)`                       | (pattern matching parameters)                     |
| _pparameter_    | ::=   | [_borrow_]{.opt} _pattern_ [``:`` _type_]{.opt} [`=` _expr_]{.opt}           |                      |
| &nbsp;         |       |                                                                               |                      |
| _paramid_      | ::=   | _identifier_ &bar; _wildcard_                                              |                      |
| _borrow_       | ::=   | ``^``                                                                         | (not allowed from _conparams_)                    |
| &nbsp;         |       |                                                                               |                      |
| _qidentifier_  | ::=   | _qvarid_ &bar; _qidop_ &bar; _identifier_                               |                      |
| _identifier_   | ::=   | _varid_ &bar; _idop_                                                       |                      |
| &nbsp;         |       |                                                                               |                      |
| _qoperator_    | ::=   | _op_                                                                          |                      |
| _qconstructor_ | ::=   | _conid_ &bar; _qconid_                                                     |                      |
{.grammar .parse}

### Statements

| ~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _block_     | ::=   | ``{`` _semis_ [_statement_ _semi_]{.many} ``}`` |                                          |
| &nbsp;      |       |                                                 |                                          |
| _statement_ | ::=   | _decl_                                          |                                          |
|             | &bar; | _withstat_                                      |                                          |
|             | &bar; | _withstat_ `in` _expr_                          |                                          |
|             | &bar; | _returnexpr_                                    |                                          |
|             | &bar; | _basicexpr_                                     |                                          |
| &nbsp;      |       |                                                 |                                          |
| _decl_      | ::=   | `fun` _fundecl_                                 |                                          |
|             | &bar; | `val` _apattern_ `=` _blockexpr_                | (local values can use a pattern binding) |
|             | &bar; | `var` _binder_ ``:=`` _blockexpr_               |                                          |
{.grammar .parse}

### Expressions


| ~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _blockexpr_   | ::=   | _expr_                                                                      | (_block_ is interpreted as statements) |
| &nbsp;        |       |                                                                             |                                        |
| _expr_        | ::=   | _withexpr_                                                                  |                                        |
|               |       | _block_                                                                     | (interpreted as ``fn(){...}``)           |
|               |       | _returnexpr_                                                                |                                        |
|               |       | _valexpr_                                                                   |                                        |
|               |       | _basicexpr_                                                                 |                                        |
| &nbsp;        |       |                                                                             |                                        |
| _basicexpr_   | ::=   | _ifexpr_                                                                    |                                        |
|               | &bar; | _fnexpr_                                                                    |                                        |
|               | &bar; | _matchexpr_                                                                 |                                        |
|               | &bar; | _handlerexpr_                                                               |                                        |
|               | &bar; | _opexpr_                                                                    |                                        |
| &nbsp;        |       |                                                                             |                                        |
| _ifexpr_      | ::=   | `if` _ntlexpr_ `then` _blockexpr_ [_elif_]{.many} [`else` _blockexpr_]{.opt} |                                        |
|               | &bar; | `if` _ntlexpr_ `return` _expr_                                              |                                        |
| _elif_        | ::=   | `elif` _ntlexpr_ `then` _blockexpr_                                         |                                        |
| &nbsp;        |       |                                                                             |                                        |
| _matchexpr_   | ::=   | `match` _ntlexpr_ `{` _semis_ [_matchrule_ _semi_]{.many} `}`               |                                        |
| _returnexpr_  | ::=   | `return` _expr_                                                             |                                        |
| _fnexpr_      | ::=   | `fn` _funbody_                                                              | (anonymous lambda expression)                                       |
| _valexpr_     | ::=   | `val` _apattern_ `=` _blockexpr_ `in` _expr_                                |                                        |
| &nbsp;        |       |                                                                             |                                        |
| _withexpr_    | ::=   | _withstat_ `in` _expr_                                                      |                                        |
| _withstat_    | ::=   | `with` _basicexpr_                                                          |                                        |
|               |       | `with` _binder_ `<-` _basicexpr_                                            |                                        |
|               |       | `with` [`override`]{.opt} _heff_  _opclause_                                | (with single operation)                       |
|               |       | `with` _binder_ `<-` _heff_  _opclause_                                     | (with named single operation)                  |
{.grammar .parse}

### Operator expressions

For simplicity, we parse all operators as if they are left associative with
the same precedence. We assume that a separate pass in the compiler will use
the fixity declarations that are in scope to properly associate all operators
in an expressions.

| ~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _opexpr_     | ::=   | _prefixexpr_ [_qoperator_ _prefixexpr_]{.many}   |                              |
| _prefixexpr_ | ::=   | [``!`` &bar; ``~``]{.many} _appexpr_      |                              |
| _appexpr_    | ::=   | _appexpr_ `(` [_arguments_]{.opt} `)`        | (regular application)        |
|              | &bar; | _appexpr_ `[` [_arguments_]{.opt} `]`        | (index operation)            |
|              | &bar; | _appexpr_ (_fnexpr_ &bar; _block_)        | (trailing lambda expression) |
|              | &bar; | _appexpr_ `.` _atom_                         |                              |
|              | &bar; | _atom_                                       |                              |
| &nbsp;       |       |                                              |                              |
| _ntlexpr_       | ::=   | _ntlprefixexpr_ [_qoperator_ _ntlprefixexpr_]{.many} |  (non trailing lambda expression) |
| _ntlprefixexpr_ | ::=   | [``!`` &bar; ``~``]{.many} _ntlappexpr_           |                                   |
| _ntlappexpr_ | ::=   | _ntlappexpr_ `(` [_arguments_]{.opt} `)`     | (regular application)        |
|              | &bar; | _ntlappexpr_ `[` [_arguments_]{.opt} `]`     | (index operation)            |
|              | &bar; | _ntlappexpr_ `.` _atom_                      |                              |
|              | &bar; | _atom_                                       |                              |
| &nbsp;       |       |                                              |                              |
| _arguments_  | ::=   | _argument_ [`,` _argument_]{.many}           |                              |
| _argument_   | ::=   | [_identifier_ `=`]{.opt} _expr_              |                              |
{.grammar .parse}


### Atomic expressions

| ~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _atom_     | ::=   | _qidentifier_                                                  |                            |
|            | &bar; | _qconstructor_                                                 |                            |
|            | &bar; | _literal_                                                      |                            |
|            | &bar; | _mask_                                                         |                            |
|            | &bar; | `(` `)`                                                        | (unit)                     |
|            | &bar; | `(` _annexpr_ `)`                                              | (parenthesized expression) |
|            | &bar; | `(` _annexprs_ `)`                                             | (tuple expression)         |
|            | &bar; | `[` [_annexpr_ [`,` _annexprs_]{.many} [`,`]{.opt} ]{.opt} `]` | (list expression)          |
| &nbsp;     |       |                                                                |                            |
| _literal_  | ::=   | _natural_ &bar; _float_ &bar; _charlit_ &bar; _stringlit_   |                            |
| _mask_     | ::=   | `mask` [`behind`]{.opt} `<` _tbasic_ `>`                       |                            |
| &nbsp;     |       |                                                                |                            |
| _annexprs_ | ::=   | _annexpr_ [`,` _annexpr_]{.many}                               |                            |
| _annexpr_  | ::=   | _expr_ [``:`` _typescheme_]{.opt}                              |                            |
{.grammar .parse}

### Matching

| ~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _matchrule_ | ::=   | _patterns_ [``\(&bar;\)`` _expr_]{.opt} `->` _blockexpr_ |                                              |
| &nbsp;      |       |                                                          |                                              |
| _apattern_  | ::=   | _pattern_ [`:` _typescheme_]{.opt}                       |                                              |
| _pattern_   | ::=   | _identifier_                                             |                                              |
|             | &bar; | _identifier_ `as` _apattern_                              | (named pattern)                              |
|             | &bar; | _qconstructor_ [`(` [_patargs_]{.opt} `)`]          |                                              |
|             | &bar; | `(` [_apatterns_]{.opt} `)`                              | (unit, parenthesized pattern, tuple pattern) |
|             | &bar; | `[` [_apatterns_]{.opt} `]`                              | (list pattern)                               |
|             | &bar; | _literal_                                                |                                              |
|             | &bar; | _wildcard_                                               |                                              |
| &nbsp;      |       |                                                          |                                              |
| _patterns_  | ::=   | _pattern_ [`,` _pattern_]{.many}                         |                                              |
| _apatterns_ | ::=   | _apattern_ [`,` _apattern_]{.many}                       |                                              |
| _patargs_   | ::=   | _patarg_ [`,` _patarg_]{.many}                           |                                              |
| _patarg_    | ::=   | [_identifier_ `=`]{.opt} _apattern_                      | (possibly named parameter)                   |
{.grammar .parse}


### Effect Declarations

| ~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~|
| _effectdecl_  | ::=   | [_named_]{.opt} _effectmod_ `effect` _varid_ [_typeparams_]{.opt} [_kannot_]{.opt} [_opdecls_]{.opt}       |    |
|               | &bar; | [_named_]{.opt} _effectmod_ `effect` [_typeparams_]{.opt} [_kannot_]{.opt} _opdecl_                        |    |
|               | &bar; | _named_ _effectmod_ `effect` _varid_ [_typeparams_]{.opt} [_kannot_]{.opt} `in` _type_ [_opdecls_]{.opt}   |    |
| _effectmod_   | ::=   | [`linear`]{.opt} [`rec`]{.opt}                                                                             |    |
| _named_       | ::=   | `named`                                                                                                    |    |
| &nbsp;        |       |                                                                                                            |    |
| _opdecls_     | ::=   | `{` _semis_ [_opdecl_ _semi_]{.many} `}`                                                                   |    |
| _opdecl_      | ::=   | [ _pub_]{.opt} `val` _identifier_ [_typeparams_]{.opt}  ``:`` _tatom_                                      |    |
|               | &bar; | [ _pub_]{.opt} (`fun` &bar; `ctl`) _identifier_ [_typeparams_]{.opt} _parameters_ ``:`` _tatom_         |    |
{.grammar .parse}

### Handler Expressions

| ~~~~~~~~~~~~~~| ~~~~~~| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| ~~~|
| _handlerexpr_ | ::=   | [`override`]{.opt} `handler` _heff_  _opclauses_                 |    |
|               | &bar; | [`override`]{.opt} `handle` _heff_ `(` _expr_ `)` _opclauses_    |    |
|               | &bar; | `named` `handler` _heff_  _opclauses_                            |    |
|               | &bar; | `named` `handle` _heff_ `(` _expr_ `)` _opclauses_               |    |
| _heff_        | ::=   | [`<` _tbasic_ `>`]{.opt}                                         |    |
| &nbsp;        |       |                                                                  |    |
| _opclauses_ | ::=   | `{` _semis_ [_opclausex_ _semi_]{.many} `}`                      |    |
|             |       |                                                                  |    |
| _opclausex_ | &bar; | _opclause_                                                       |    |
|             | &bar; | `finally` _blockexpr_                                            |    |
|             | &bar; | `initially` `(` _oparg_ `)` _blockexpr_                          |    |
| &nbsp;      |       |                                                                  |    |
| _opclause_  | ::=   | `val` _qidentifier_ [`:` _type_]{.opt} `=` _blockexpr_           |    |
|             | &bar; | `fun` _qidentifier_ _opargs_ _blockexpr_                         |    |
|             | &bar; | [_ctlmod_]{.opt}`ctl` _qidentifier_ _opargs_ _blockexpr_         |    |
|             | &bar; | `return` `(` _oparg_ `)` _blockexpr_                             |    |
| _ctlmod_    | ::=   | `final` &bar; `raw`                                              |    |
| &nbsp;      |       |                                                                  |    |
| _opargs_    | ::=   | `(` [_oparg_ [`,` _oparg_]{.many}]{.opt} `)`                     |    |
| _oparg_     | ::=   | _paramid_ [``:`` _type_]{.opt}                                   |    |
{.grammar .parse}

### Type schemes

|~~~~~~~~~~~~~~|~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~|~~~|
| _typescheme_ | ::= | _somes_ _foralls_ _tarrow_ [_qualifier_]{.opt} |             |   |
| _type_       | ::= | _foralls_ _tarrow_ [_qualifier_]{.opt}         |             |   |
| &nbsp;       |     |                                                |             |   |
| _foralls_    | ::= | [`forall` _typeparams_]{.opt}                  |             |   |
| _some_       | ::= | [`some` _typeparams_]{.opt}                    |             |   |
| &nbsp;       |     |                                                |             |   |
| _qualifier_  | ::= | `with` `(` _predicates_ `)`                    |             |   |
| &nbsp;       |     |                                                |             |   |
| _predicates_ | ::= | _predicate_ [`,` _predicate_]{.many}           |             |   |
| _predicate_  | ::= | _typeapp_                                      | (interface) |   |
{.grammar .parse}

### Types

|~~~~~~~~~~~|~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _tarrow_  | ::=    | _tatom_ [`->` _tresult_]{.opt}                                                 |                                        |
| _tresult_ | ::=    | _tatom_ [_tbasic_]{.opt}                                                       |                                        |
| &nbsp;    |        |                                                                                |                                        |
| _tatom_   | ::=    | _tbasic_                                                                       |                                        |
|           | &bar;  | `<` _anntype_ [`,` _anntype_]{.many} [``\(&bar;\)`` _tatom_]{.opt} `>` |                                        |
|           | &bar;  | `<` `>`                                                                        |                                        |
| &nbsp;    |        |                                                                                |                                        |
| _tbasic_  | ::=    | _typeapp_                                                                      |                                        |
|           | &bar;  | `(` `)`                                                                        | (unit type)                            |
|           | &bar;  | `(` _tparam_ `)`                                                               | (parenthesized type or type parameter) |
|           | &bar;  | `(` _tparam_ [`,` _tparam_]{.many} `)`                                         | (tuple type or parameters)             |
|           | &bar;  | `[` _anntype_ `]`                                                              | (list type)                            |
| &nbsp;    |        |                                                                                |                                        |
| _typeapp_ | ::=    | _typecon_ [`<` _anntype_ [`,` _anntype_]{.many} `>`]{.opt}                     |                                        |
| &nbsp;    |        |                                                                                |                                        |
| _typecon_ | ::=    | _varid_ &bar; _qvarid_                                                      |                                        |
|           | &bar;  | _wildcard_                                                                     |                                        |
|           | &bar;  | `(` `,` [`,`]{.many} `)`                                                       | (tuple constructor)                    |
|           | &bar;  | `[` `]`                                                                        | (list constructor)                     |
|           | &bar;  | `(` `->` `)`                                                                   | (function constructor)                 |
| &nbsp;    |        |                                                                                |                                        |
| _tparam_  | ::=    | [_varid_ ``:``]{.opt} _anntype_                                                  |                                        |
| _anntype_ | ::=    | _type_ [_kannot_]{.opt}                                                        |                                        |
{.grammar .parse}

### Kinds

|~~~~~~~~~~|~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
| _kannot_ | ::=   | ``::`` _kind_                                  |                              |
| &nbsp;   |       |                                                |                              |
| _kind_   | ::=   | `(` _kind_ [`,` _kind_]{.many} `)` `->` _kind_ |                              |
|          | &bar; | _katom_ `->` _kind_                            |                              |
|          | &bar; | _katom_                                        |                              |
| &nbsp;   |       |                                                |                              |
| _katom_  | ::=   | `V`                                            | (value type)                 |
|          | &bar; | `X`                                            | (effect type)                |
|          | &bar; | `E`                                            | (effect row)                 |
|          | &bar; | `H`                                            | (heap type)                  |
|          | &bar; | `P`                                            | (predicate type)             |
|          | &bar; | `S`                                            | (scope type)                 |
|          | &bar; | `HX`                                           | (handled effect type)        |
|          | &bar; | `HX1`                                          | (handled linear effect type) |
{.grammar .parse}

### Implementation

As a companion to the Flex lexical implementation, there is a full
Bison(Yacc) LALR(1) [implementation][BisonGrammar]
available. Again, the Bison parser functions
as _the_ specification of the grammar and this document should always
be in agreement with that implementation.

[BisonGrammar]: https://github.com/koka-lang/koka/blob/master/doc/spec/grammar/parser.y
[FlexLexer]:    https://github.com/koka-lang/koka/blob/master/doc/spec/grammar/lexer.l
[HaskellLayout]:   https://github.com/koka-lang/koka/blob/dev/src/Syntax/Layout.hs#L181